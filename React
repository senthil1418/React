What is React?
   - Open source javascript library for building user interfaces
   - React is javascript library, it is not a framework and focus on building user interfaces
   - React does not focus on other aspects of application like Routing or HTTP requests, it is responsible for building rich user interfaces 
   - How u would handle routing, HTTP and other functionality , React has rich ecosystem and plays well with other libraries and is more than capable of building full fledged web application

Why React?
   - React is a project created and maintained by Facebook, when a company like Facebook  uses react in its own product and invests money and resources to keep the project alive, so it is assured it is not going to die down anytime 
   - React has component based architecture which breaks down ur appl into small encapsulated parts which can then be composed to make more complex UI'ss. For example a traditional website can be broken down into header side, nav, main content and footer. Each section represents a component which when composed in right way to make entire website 
   - Components also make it possible to write reusable code, for example u could have component for an article on React, the same component can be reused for articles on Angular or vue by passing the right data into the article component
   - React is declarative which mean we have to tell react what we want and react with its React DOM library will build actual UI. For example, lets say u go to an artist, u ask them to draw a landscape, u dont tell them how to draw it, its up to them, this is declarative. Now the same task u ask a child, this time u tell them to first draw mountains, then rivers, then trees and so on. You explicitly tell each steps and u control the flow of landscape which is imperative style
   This is important because react is declarative, u have to tell react what UI should look like and react will create actual UI. 
   - React will handle efficiently updating and rendering of the component when ur data changes
   - DOM updates are handled gracefully in react 
   - React also makes no assumption about rest of technology stack u r using for the project, we can seamlessly integrate react with any of ur appl
   - React will fit right in to portion of ur page or a complete page or even an entire appl itself 
   - React native for mobile appl

Prerequisites
  - HTML, CSS, JS
  - ES6

Installation
1. Nodejs
2. Visual Studio code

Example 1: Hello world
Step 1: Create react project
   >npx create-react-app hello-world(project name)

Step 2: To run the app
   >cd hello-world
  hello-world> npm start 

Run localhost:3000

Step 3: Goto App.js and edit
    <p> Hello World </p>

Creation of React project - 2 ways

1. Using npx create-react-app "project name"
npx is npm package runner which gets installed when u install node 

2. Using npm
    Here we install create-react-app package globally and then use the package to generate the project 
   >npm install create-react-app -g 
   >create-react-app "project name"

Folder structure
    1. package.json
            - contains dependencies and scripts required for the project 
            - Based on whether we have just NPM or yarn as package manager, we can see yarn lock or package.lock files

2. node_modules - contains all the dependencies are installed 
3. public folder
    1. favicon.ico which we see in browser folder
    2. index.html - starting file loaded by appl, it has
   <div id="root"></div>
 which is ultimately responsible for UI 
3. src folder- where we work during development 
    - Starting point of appl is index.js where we specify the root component is AppComponent and DOM element which will be controlled by react, in our case it is element with id "root: which is represented in index.html file. So finally App component is rendered inside root DOM node 
    - App.js is App component and it is responsible for the html displayed in browser 
    - App.css for styling App component
    - App.test.js for unit test
    - index.css applies style for body tag 
    - logo.svg which is referenced in app component 

When we run npm start, index.html is served in browser which contains root DOM node. Next control enters index.js, ReactDOM renders the app component on to root DOM node. App component contains HTML which ultimately displayed in browser


Components
   In react, component represents a part of the user interface. For example in our appl, we have 5 components, one for header, one for sidenav, one for main content, one for footer and finally one component which contain every other component. The containing component is root component and it is usually named as app component in ur appl, each of 4 components describe only a part of the user interface, however all the components come together to make up the entire application.
     Components are also reusable, the same component can be used with different properties to display different information. For example the sitenav component can be the leftside nav as well as right sidenav 
     Component code is placed in javascript file (ie) App.js, but u can also have component with .jsx extension. So component is basically the code inside .js file, but the code  look like that depends on the type of the component 

In react, we have 2 types of component
   1. Stateless functional component
         - Functional components are literally Javascript functions that return HTMl which describes the UI 
eg:  function welcome(props) {
          return <h1>Hello, {props.name}</h1>;
     }
Welcome function which returns h1 tag to html

   2. Stateful class component
          - It is regular es6 class that extends Component class from react library, they must contain render() which in turn returns HTML
eg: class Welcome extends React.Component {
       render() {
          return <h1>Hello, {this.props.name}</h1>;
       }
    }

So App.js is a class component that extends Component with render() method which returns HTML 


Functional Component
    - Functional components are just Javascript functions, they can optionally receive an object of properties which is referred as props and return HTML which describes the UI. HTML is called as JSX 
    - So Functional components is a Javascript functions that accepts an input of properties and returns HTML that describes UI

Example:
1. Create components folder inside src folder
2. Create greet.js inside components folder

import React from 'react'

function Greet() {
    return <h1>Hello Senthil</h1>
}

But Hello senthil will not display in HTML, since Greet component is not connected with App component. So we export Greet() function from greet.js, import in App.js and include in App component 

3. import React from 'react'

function Greet() {
    return <h1>Hello Senthil</h1>
}

export default Greet

4. Import in App.js as

import Greet from './components/Greet'

render() {
   return (
     <div className="App">
        <Greet/>
     </div>
   );
}

5. Run the program, it will display "Hello Senthil" in browser

6. Now we write Greet() with arrow function in es6

const Greet = () => <h1>Hello Senthil</h1>

export default Greet

Note on Exporting and Importing Component
1. Here we exporting Greet component as default export from greet.js, this allows us to import the component to any name. We can change Greet to MyComponent, so in App.js

import MyComponent from './components/Greet'

function App() {
  return (
    <div className="App">
        <MyComponent/>
    </div>
  );
}

export default App; 

2. Named exports
      Instead of defining export separately, we can export the const, in this case we have to import the component with same name 

Greet.js   
const Greet = () => <h1>Hello Senthil</h1>

App.js
import {Greet} from './components/Greet'

function App() {
  return (
    <div className="App">
        <Greet/>
    </div>
  );
}

export default App; 


Class Components
    - Similar to es6 classes, similar to functional compoennt a class component also can optionally receive props as input and return HTML. 
    - Apart from props, a class component can also maintain a private internal state (ie) it can maintain some information which is private to that component and use that information to describe user interface

1. Create Welcome.js inside components folder, we have provide with 2 imports

import React, {Component} from 'react'
class Welcome extends Component {
    render() {
       return <h1>Class Component</h1>
    }
}

export default Welcome

2. In App.js

import Welcome from './components/Welcome'

function App() {
  return (
    <div className="App">
        <Greet/>
        <Welcome/>
    </div>
  );
}

export default App; 


Functional Components			Class Components
1. It is simple functions	    1. More feature rich
receiving props and 
returning HTML

2. Use functional components        2. Maintian their own 
as much as possible                 private data called state

3. Absence of 'this' keyword        3. complex UI logic and
which u will encounter in a          provide lifecycle hooks
class based component

4. Forced to think of solution      4. It is called stateful/
without having use of state. If      smart or container comp
there are number of components
each with their own private
state, maintainence and debugging
ur appl is kind of difficult

5. Mainly responsible for UI,so
functional component are also
called stateless or dumb or
presentational components


But in React16.7.0, they have introduce new concept called Hooks which lets you use state and other react features withou writing the class 


JSX(JavaScript XML)
    - It is an extension to the Javascript language syntax with react library
    - It is extension to write XML like code for elements and components 
    - Like XML, JSX tags have tag name, attributes and children
    - JSX is not necessity to write react applications, but JSX makes ur react code simpler and elegant
    - JSX ultimately transpiles to pure Javascript which is understood by the browsers
    - In react components, there is one important rule, regarding this HTML, this JSX code which you return, inside of a component. You must only have, one root element here, per return statement or per JSX code snippet

1. Create Hello.js inside components folder which is functional component with JSX and renders in HTML

import React from 'react'

const Hello = () => {
       return (
          <div className="dummyClass">
             <h1>Hello JSX</h1>
          </div>
       )
}
export default Hello

2. Import in App.js

import Hello from './components/Hello'

function App() {
  return (
    <div className="App">
        <Greet/>
        <Welcome/>
        <Hello/>
    </div>
  );
}

export default App;

3. Rewrite the component without JSX, for that react library provide with createElement() which accepts 3 parameters, the first parameter is string which specifies HTML tag to be rendered, the second parameter we get to pass any optional properties and in our case it is null, thrid parameter is the any number of children for HTML element (ie) children for div tag

import React from 'react'

const Hello = () => {
    return React.createElement('div',null,React.createElement('h1',null,'Hello Senthil'))
}
export default Hello

Second parameter is an object of key value pairs that will be applied to the element. For example we need an ID and class attribute on this div tag we can specify an object key id ID and value is hello and class as dummy.
   In react, CSS class has to be specified using the className attribute, because in Javascript class is reserved word

import React from 'react'

const Hello = () => {
    return React.createElement('div',
{id:'hello',className:'dummyClass'},
React.createElement('h1',null,'Hello Senthil'))
}
export default Hello

Inspect the webpage and we can see id and class attribute


JSX Difference
1. class -> className
2. for -> htmlFor
3. camelCase property naming convention
     onclick -> onClick
     tabindex -> tabIndex

Props
    We can create a component that returns any JSX u want and include it in any part of ur appl.  
    Props are immutable (ie) the values cannot be changed  
    For example, we want to reuse Greet component for that

function App() {
  return (
    <div className="App">
        <Greet/>
        <Greet/>
        <Greet/>
       {/*  <Welcome/> */ }
       {/* <Hello/> */}
    </div>
  );
}

Now it will display "Hello Senthil" 3 times, instead we want to pass name of the person we wanted to greet, so that reusing same component we can greet 3 different people, in that case probs will comes into picture 
    Props short for properties is the optional input that ur component can accept, it allows the component to be dynamic.

Here we want to pass name from App component to Greet component and display that is browser. To specify props for component we specify them as attributes 
    
In App.js
     <Greet name="Tim" heroName="Batman"/>
    <Greet name="Jim" heroName="Superman"/>
    <Greet name="Jam" heroName="Catman"/>

To retrieve value in Greet component we add parameter to the functional Component as props(we can give anyname but mostly props) and use that parameter in function body 

const Greet = (props) => {
    console.log(props);
    return <h1>Hello {props.name} {props.heroName}</h1>
}

Now we want to render the content between the components and retrieve it by using the reserved children property in props object 

In App.js
   <Greet name="Tim" heroName="Batman">
       <p>This is children props</p>    
    </Greet>

In Greet.js

const Greet = (props) => {
    console.log(props);
    return(
        <h1>Hello {props.name} {props.heroName}</h1>
        {props.children}
    )
}

It shows the error since JSX should contain only one wrapper element, so we wrap both the elements within <div> tag, so we can return only one html element

const Greet = (props) => {
    console.log(props);
    return(
        <div>
        <h1>Hello {props.name} {props.heroName}</h1>
        {props.children}
        </div>
    )
}

Finally props will be passed them as attributes and if we want to pass the content which is in between the component tags and in content defination simply render the content using props.children

Props with class component
    Irrespective of component type, the properties are mentioned as attributes during the component invocation. Now we duplicate Welcome component which is class component twice with name and heroName attributes and it is accessible using this.props.name 

In App.js
       <Welcome name="Tim" heroName="Batman"/>
       <Welcome name="Tim" heroName="Batman"/>
       <Welcome name="Jam" heroName="Catman"/>

In Welcome.js
class Welcome extends Component {
    render() {
      // return <h1>Class Component</h1>
      return <h1>Welcome {this.props.name} and {this.props.heroName}</h1>
    }
}


Component State in React 
    Every react component returns JSX which describes the user interface and we can unfluence what is rendered on the screen using props
    There is another way to influence what is rendered on the screen using state of components

props					state
1. props get passed to the 	1. State is managed within 
components                       the component
2. Function parameters          2. Variables declared in 
                                   function body
3. Because parent usually       3. State is managed within 
passes down the props to         the component and so
child component, props           component has full control
are immutable                    to change the state
4. In functional component      4. State can be accessed with
props can be accessed using       useState Hook in functional
props parameter, in class         component and this.state in 
components props can be           class components
accessed using this.props


Example:
1. Create Message.js 

import React, {Component} from 'react'
class Message extends Component {
    render() {
      return <h1>Welcome Visitor</h1>
    }
}

export default Message

2. Include the component is App.js

function App() {
  return (
    <div className="App">
      { /* <Greet/>
        <Greet/>
      <Greet/> */ }
   { /* <Greet name="Tim" heroName="Batman">
       <p>This is children props</p>    
    </Greet>
    <Greet c>
        <button>Action</button>
    </Greet>
    <Greet name="Jam" heroName="Catman"/> /*}
       {/*  <Welcome/> */ }
       {/* <Hello/> */}
      {/* <Welcome name="Tim" heroName="Batman"/>
       <Welcome name="Tim" heroName="Batman"/>
    <Welcome name="Jam" heroName="Catman"/> */}
    <Message/>
    </div>
  );
}
Now it will display Welcome Visitor in browser

3. Now the requirement is we need subscribe button below the text and when we click on button, the text being displayed should change from Welcome Visitor to Thank you
   Now if the message is send from App.js as property, it will not work as props are immutable, once the message is said to welcome visitor, it can never be changed from message component and so the solution is to use component state

1. Create state object and initialize it inside class constructor 
    constructor() {
         super();
         this.state = {
             message:'Welcome visitor'
         } 
    }
2. Now bind this state value in render function using this.state
   render() {
      return <h1>{this.state.message}</h1>
    }

3. Create a button to change the message inside single <div> tag since JSX can have only one wrapper tag

render() {
      return(
           <div>
             <h1>{this.state.message}</h1>
             <button>Subscribe</button>
           </div>
      )
  }

4. Create click onClick event on this button to change the message, to this event we assign a handler within curly braces and fat arrow function
 <button onClick={()=>this.changeMessage()}>Subscribe</button>

5. Create changeMessage() after constructor, to change the state of the component we need to call setState() which accepts the object which is nothing but new state of the component (ie) new message 
   changeMessage() {
       this.setState({
           message:'Thank you'
       })
   }
Now click subscribe button which will change 'Welcome Visitor' to 'Thank you'

React Snippets
   Instead of typing the general code each time, we can use react snippets in vscode, so there is no need to type the basic codes

https://marketplace.visualstudio.com/items?itemName=burkeholland.simple-react-snippets

https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets

rce - press tab, it will create basic class component
rconst - press tab, it will create constructor

setState method
Rule 1: Never modify the state directly instead use setState, so when u modify the state directly react will not rerender the component, whereas setState will rerender the component 
1. Create Counter.js which is class component

import react,{Component} from 'react'

class Counter extends Component {
    render(){
        return(
            <div>
                count
            </div>
        )
    }
}

export default Counter

2. Add Counter component in App component (App.js)
function App() {
  return (
    <div className="App">
      { /* <Greet/>
        <Greet/>
      <Greet/> */ }
   { /* <Greet name="Tim" heroName="Batman">
       <p>This is children props</p>    
    </Greet>
    <Greet c>
        <button>Action</button>
    </Greet>
    <Greet name="Jam" heroName="Catman"/> /*}
       {/*  <Welcome/> */ }
       {/* <Hello/> */}
      {/* <Welcome name="Tim" heroName="Batman"/>
       <Welcome name="Tim" heroName="Batman"/>
    <Welcome name="Jam" heroName="Catman"/> */}
    {/*<Message/>*/}
    <Counter/>
    </div>
  );
}

3. In Counter.js, we need count state to keep track of counter value and we initialize inside constructor as 0

constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }

4. Now we can bind count value inside render(), using {}
  <div>
                count - {this.state.count}
            </div>

5. Now we add button to increment the value with onClick event 

 <div>
                count - {this.state.count}
                <button onClick={()=>this.increment()}>Increment</button>
            </div>

6. Now we create increment(), we saw previously when we have to change the state of component we use setState(). But if we not using setState() 

    increment(){
        this.state.count = this.state.count + 1
    }
So when we click increment button, the count value will be increment and prints in console but the value is not render on browser so we should not directly modify the state 

increment(){
        //this.state.count = this.state.count + 1
        this.setState({
            count : this.state.count + 1
        })
        console.log(this.state.count)
    }
Now when we click the button, the value will be rendered correctly 

Rule 2: When we click on Increment button, the value is correct in browser but in console it is 1 less than the rendered value, this is because calls to setState are asynchronous so console.log is called before the state is actually set. So if u want to execute the code only after the state has been updated, to handle such a situation u can pass  callback function which is arrow function as second parameter to setState() 

 increment(){
        this.setState({
            count : this.state.count + 1
        }, ()=>{
            console.log('Callback value',this.state.count)
        })
        console.log(this.state.count)
    }
So setState() takes 2 parameter, the first parameter is an object which sets the state value and second parameter is arrow function where we simply log the updated value

Rule 3: When we have to update the state based on previous state, we have to pass function as an argument instead of regular object 
   Now we create incrementFive() and inside the body we call increment() 5 times and in onClick we call incrementFive()

 incrementFive(){
        this.increment()
        this.increment()
        this.increment()
        this.increment()
        this.increment()
    }

  <button onClick={()=>this.incrementFive()}>Increment</button>

So when we click the button, the value change to 1 instead of 5 and in console 0 is logged 5 times and callback value also logged 5 times, this is because react may group multiple setState calls into single update for better performance. So all 5 setState calls are done in one single go and the updated value does not carry over between the different calls.
   So whenever u have to update the state based on previous state we need to pass a function as an argument to setState() instead of passing in an object.
  So we pass arrow function and for that function we pass previous state of the component 

increment() {
   this.setState(prevState => ({
           count : prevState.count + 1
       }))
       console.log(this.state.count)
}


Destructuring props and state
    Destructuring is ES6 feature that makes it possible to unpack values from arrays or properties from objects into distinct variables 

2 ways to destructure props in Functional component 
1. Destructure in function parameter itself 

In Greet.js,
const Greet = ({name,heroName}) => {
    return(
        <div>
        <h1>Hello {name} {heroName}</h1>
        </div>
    )
}

In App.js,
<Greet name="Jam" heroName="Catman"/>     


2. Destructuring in Function body 
const Greet = props => {
    const {name,heroName} = props
    return(
        <div>
        <h1>Hello {name} {heroName}</h1>
        </div>
    )
}

Destructuring props in class component
Welcome.js
class Welcome extends Component {
  render() {
    const {name, heroName} = this.props
    return <h1>Welcome {name} and {heroName}</h1>
  }
}

export default Welcome

App.js
 <Welcome name="Tim" heroName="Batman"/>


Event Handling
   When user interacts with your appl, events are fired. For example mouse clicks, mouse over, key press, change event and so on
   Event handler is function and not a function call 

Event handling Functional Component
1. Create FunctionClick.js 
     - create functional component using react snippet rfce
     - Add button Click 

function FunctionClick() {
    return (
        <div>
          <button>Click</button>  
        </div>
    )
}

export default FunctionClick

2. Add component in App.js
<FunctionClick/>

3. We have to capture the click event for that button.
    - React events are named using camel case rather than lowercase 
    <button onClick>Click</button>  
    - With JSX, you pass a function as the event handler rather than string 
function FunctionClick() {
    function clickHandler(){
        console.log("Button clicked")
    }
    return (
        <div>
          <button onClick={clickHandler}>Click</button>  
        </div>
    )
}

export default FunctionClick

If we try to add parenthesis it becomes a function call, we want the handler to function and not function call 

function FunctionClick() {
    function clickHandler(){
        console.log("Button clicked")
    }
    return (
        <div>
          <button onClick={clickHandler()}>Click</button>  
        </div>
    )
}

export default FunctionClick

When we run, in the console message "Button Click" is already logged and when we click on button nothing happens, this scenario becomes worse in class components when ur click handler changes the state of the component 

Event handling in Class Components
1. Create ClassClick.js with rce react snippets, remove export from class
   Create button with Click me 

import React, { Component } from 'react'
 class ClassClick extends Component {
    clickHandler(){
        console.log("Clicked in Class component")
    }
    render() {
        return (
            <div>
                <button onClick={this.clickHandler}>Click Me</button>
            </div>
        )
    }
}

export default ClassClick

2. Add component in App.js
  <ClassClick/>

Binding Event Handlers
     We see on click of button we simply change a message which is part of component state 

1. Create EventBind.js and use rce to create class component, remove export from class
   Create state property called message in constructor and bind it to user interface using rconst snippet

class EventBind extends Component {
    constructor(props) {
        super(props)
    
        this.state = {
             message:'Hello'
        }
    }
    
    render() {
        return (
            <div>
                <div>{this.state.message}</div>
                <button>Click</button>
            </div>
        )
    }
}

export default EventBind

2. Import in App.js as
     <EventBind/>
When we run it will display text "Hello" and click button

3. Now we want to change "Hello" to "GoodBye" when we click button, so we create onClick event and pass event handler in curly braces

clickHandler(){
        this.setState({
            message:'GoodBye'
        })
    }
    render() {
        return (
            <div>
                <div>{this.state.message}</div>
                <button onClick={this.clickHandler}>Click</button>
            </div>
        )
    }

When we run and click the button, error will be coming says TypeError: Cannot read properties of undefined 

clickHandler(){
       // this.setState({
       //     message:'GoodBye'
       // })
console.log(this)
    }

When we run, in console it prints this to be undefined, so 'this' keyword within event handler is undefined and this is typical behaviour in Javascript, so event binding is necessary in react class components 

Different ways of event binding
1. Use bind keyword and bind the handler in render()

 clickHandler(){
        this.setState({
            message:'GoodBye'
        })
       console.log(this)
    }

    render() {
        return (
            <div>
                <div>{this.state.message}</div>
                {/*<button onClick={this.clickHandler}>Click</button>*/}
                <button onClick={this.clickHandler.bind(this)}>Click</button>
            </div>
        )
    }

Now when we click button, it will change from Hello to Goodbye
   This approach is fine so every update to state will cause component to rerender which will generate brand new event handler on every render, so performance is problem in large appl

2. Use arrow functions in render()

 <button onClick={()=>this.clickHandler()}>Click</button>

Here we are calling event handler and returning that value, so parenthese is required in this approach. This also have performance implication in some scenarios

3. Binding the event handler in constructor 

constructor(props) {
        super(props)
    
        this.state = {
             message:'Hello'
        }

        this.clickHandler=this.clickHandler.bind(this)
    }

<button onClick={this.clickHandler}>Click</button>

Because the binding happens once in constructor this is better compared to binding in render(), so it is effective one compared to others 

4. Use arrow function as class property (also effective)

  clickHandler = () => {
        this.setState({
            message:'GoodBye'
        })
    }

<button onClick={this.clickHandler}>Click</button>


Methods as Props
    Previously we saw how parent component(App.js) can pass down props to its children components(Greet.js), any data in the parent component when passed as props is available in the children components
    What if the child component want to communicate with the parent component for that also we  use props. But this time we pass in a reference to a method as props to the child component 

1. Create ParentComponent.js, use rce to create class component, use rconst to create constructor and remove export from class 
   Inside constructor we set state called parentName, create greetParent() which simply alerts "hello" followed by the parent name which is set in the state.
   Since we are using 'this' keyword in method we need to bind this method in constructor 

class ParentComponent extends Component {
    constructor(props) {
        super(props)
    
        this.state = {
            parentName:'Parent' 
        }
        this.greetParent = this.greetParent.bind(this)
    }

    greetParent(){
       // alert("Hello "+this.state.parentName) //instead of using regular concatentaion, we use template literals
       alert(`Hello ${this.state.parentName}`) //Template literal, new feature in ES6 
    }
    
    render() {
        return (
            <div/>
        )
    }
}

export default ParentComponent

2. Next we create ChildComponent.js with rfce react snippet we create Functional component
   Inside <div> we create button called "Greet Parent"

function ChildComponent() {
    return (
        <div>
            <button>Greet Parent</button>
        </div>
    )
}

export default ChildComponent

3. Include Child component inside parent component and import it 

import ChildComponent from './ChildComponent'
render() {
        return (
            <div> 
               <ChildComponent/>
            </div>
        )
    }

4. In App.js, include parent component in render() and import
<ParentComponent/>

When we run, we can see "Greet Parent" button but when we click nothing happens. But we want is when we click button in child component, we want to execute the method defined in the parent component, basically child component calls a parent component method using props, now we pass method itself as prop to the child component 

5. In ParentComponent <div> tag we add as attribute to child component 

<ChildComponent greetHandler={this.greetParent} />

Here we are passing a reference to the greetParent method as prop called greetHandler 

6. In ChildComponent create onClick event for button which calls greetHandler

function ChildComponent(props) {
    return (
        <div>
            {/*<button>Greet Parent</button>*/}
            <button onClick={props.greetHandler}>Greet Parent</button>
        </div>
    )
}

So we successfully called method in parent component from button in child component by passing the method as props to child component 

Passing a parameter when calling the parent method from child component 
    Using arrow function in return statement to pass parameter from child components to parent components 

1. In child component we create arrow function with parameter

<button onClick={()=>props.greetHandler('child')}>Greet Parent</button>

2. In ParentComponent, call this parameter in greetParent() as childName 

greetParent(childName){
       alert(`Hello ${this.state.parentName} from ${childName}`) 
    } 

When we run and click the button it prints "Hello Parent from Child", now we pass parameters from child to the parent.
   In Parent component define the method on the child component tag pass the method as a prop, in child component access the method using the props object, if we want to pass parameters use the arrow functions 

Conditional Rendering
    When we building react appl, we need to show or hide some  html based on some condition, for that we use conditional rendering 

4 types of approach
1. If/else
  - Create UserGreeting.js with rce react snippet as class component and remove export
  - Inside <div> tag print "Welcome React" and "Welcome Guest"

class UserGreeting extends Component {
    render() {
        return (
            <div>Welcome React</div>
            <div>Welcome Guest</div>
        )
    }
}

export default UserGreeting

  - Include <UserGreeting/> component in ParentComponent and import it
      <UserGreeting/>

  - Run the appl and it will prints "Welcome React"
  - Create constructor with 'rconst' react snippet with one state property called "isLoggedIn" and initialize to false
 constructor(props) {
        super(props)
    
        this.state = {
             isLoggedIn:false
        }
    }
  - Now we want to print the message based on isLoggedIn state, if we logged in it prints "Welcome React" and not logged in then it prints "Welcome Guest"
render() {
        if(this.state.isLoggedIn){
            return <div>Welcome React</div>
        } else {
            return <div>Welcome Guest</div>
        }
}
Now it will print "Welcome Guest" since isLoggedIn is false.
If/else dosent work inside JSX because JSX is syntactic output for function calls and object construction

2. Element Variable
     We use Javascript variables to store elements
   - Declare a variable "message" inside render() and store appropriate element in this variable based on the condition 

render(){
   let  message
        if(this.state.isLoggedIn){
            message = <div>Welcome React</div>
        } else {
            message = <div>Welcome Guest</div>
        }
        return <div>{message}</div>
}

3. Ternary conditional operator (most simple and readable)
       This approach is that it can be used inside JSX

return this.state.isLoggedIn ? (
           <div>Welcome React</div>
       ) : (
           <div>Welcome Guest</div>
       )
        
4. Short circuit operator
      It is specific case of ternary operator approach, when u want to render something or nothing we use short circuit operator
      In this case if user logged in, we want to display "Welcome React" and if user not logged in then we dont want to print anything 

List Rendering
    When you build web appl, a common scenario is to display list of items

1. Create NameList.js with rfce react snippet create a functional component, within the component create an array of names and display the array elements based on index

function NameList() {
    const names = ['Apple','Banana','Grapes']
    return (
        <div>
            <h2>{names[0]}</h2>
            <h2>{names[1]}</h2>
            <h2>{names[2]}</h2> 
        </div>
    )
}

export default NameList

2. Add NameList component in App.js and import it 
    <NameList/>

When we run it will display the list of names, but above is not proper solution

3. Now we use map() to render the names, and it is evaluated inside {} inside JSX since it is Javascript code. map() takes Function as an argument so we use arrow function 
 return (
        <div>
           { names.map(name => <h2>{name}</h2>)  }
        </div>
    )
To be more simple, we can move logic outside return and we can just return the list inside JSX

function NameList() {
    const names = ['Apple','Banana','Grapes']
    const nameList = names.map(name => <h2>{name}</h2>)
    return <div>{nameList}</div> 
}

export default NameList 

4. We have list of objects with few properties that have to be rendered, in such case we have to refactor JSX in separate component and use the component in map().

Create array of person in NameList.js

 const persons = [
       {
           id:1,
           name:'Ram',
           age:25,
           skill:'Java'
       },
       {
           id:2,
           name:'Sam',
           age:26,
           skill:'J2EE'
       },
       {
           id:3,
           name:'Raj',
           age:24,
           skill:'J2ME'
       },
       {
           id:4,
           name:'Ramu',
           age:28,
           skill:'PHP'
       }
   ]

const personList = persons.map(person => (
      <h2>I am {person.name}. I am {person.age} years old.I know {person.skill}</h2>
   ))
    return (
        <div>
          {personList}
        </div>
    )
}   

5. Now we refactor JSX into separate component, so we create Person.js with rfce react snippet and create functional component 
    Remove JSX from NameList component and include in Person.js file
    Copy  <h2>I am {person.name}. I am {person.age} years old.I know {person.skill}</h2> and paste inside Person.js

6. But how Person component knows the person data, so we pass the data as props from NameList component
   So in NameList component, inside map() include the Person component by passing person as a prop

const personList=persons.map(person => <Person person={person}/>)

7. In Person.js we destructure the prop in parameter
function Person({person}) {
    return (
        <div>
             <h2>I am {person.name}. I am {person.age} years old.I know {person.skill}</h2>
        </div>
    )
}

export default Person

When we Run, it will display all list of names, so NameList component is only responsible for rendering the list and person component is responsible for rendering Person html. Even though in browser console we can see warning message  

Lists and Keys
   Previously when we render list of items react shows a warning in the console (ie) each child in an array or iterator should have a unique key prop or each item in list rendered using map operator should have a prop called key and  value to that prop should be unique within the list

1. In NameList component, within map() we add key prop with unique value within the list (ie) id property of Person array

const personList=persons.map(person => <Person key={person.id} person={person}/>)

Now when we run, it wont show any warning in browser console. Even the key property can be anything but it should be unique, so even name can be also considered as key

const personList=persons.map(person => <Person key={person.name} person={person}/>) 

Key prop is a special attribute u need to include when creating lists of elements. The key components is not accessible in child component


Styling React Component
1. CSS stylesheets
    - Create StyleSheet.js with rfce create functional component 
function StyleSheet() {
    return (
        <div>
            <h1>Stylesheet</h1>
        </div>
    )
}

export default StyleSheet
   - Import StyleSheet component in App.js and import it
       <StyleSheet/>
   - To specify css for StyleSheet component, create myStyles.css
    .primary{
          color: orange
    }
   - To use this class in our component, import that style sheet 
    import './myStyles.css'
   - Now specify className attribute in <h1> tag
     <h1 className='primary'>StyleSheet</h1>
When we run, the text will display in orange color
   - You can conditionally apply a class based on props or state of the component. For example we pass a prop called primary and set it defaults to false
      <StyleSheet primary={false}/>
   - Now we use the props in component and pass props as parameter and within the body set className 
function StyleSheet(props) {
    let className = props.primary ? 'primary' : ' '
    return (
        <div>
            <h1 className={className}>Stylesheet</h1>
        </div>
    )
}

    - If u want to use multiple classes, we can use template literals. Create class in myStyles.css

.font-xl {
     font-size: 72px;
}
   - Now in component we change the value of className attribute to template literal using backtick 
<h1 className={`${className} font-xl`}>StyleSheets</h1><h1 className={`${className} font-xl`}>StyleSheets</h1>
  Now we have applied primary and font-xl classes to component

2. Inline styling 
     - Create Inline.js and with react snippet rfce create functional component and in return stmt add <h1> tag
function Inline() {
    return (
        <div>
            <h1>Inline</h1> 
        </div>
    )
}

export default Inline
   
   - In react, inline styles are not specified as string, instead they are specified with an object whose key is camel case version of style name and value is string 
    Create new object called heading with fontSize as 72pixels, here key is CSS property name but in camelcase and value specified as string and multiple property is separated by comma
   const heading={
        fontSize:'72px',
        color:'blue'
   }
   - To apply inline style we use style attribute 
   <h1 style={heading}>Inline</h1>
   - Include Inline component inside App.js
      <Inline/>

3. CSS Modules
       - It is available with react scripts version2 or higher. There is file naming conventions used for CSS modules  and file name must be suffixed with .module.css
       - Create 2 stylesheet in source folder appStyles.css and appStyles.module.css
       - In appStyles.css which is regular stylesheet we create 
.error{
    color:red
}
       - In appStyles.module.css which is module stylesheet we create
.success {
     color:green
}
       - Import this stylesheet in App.js
import './appStyles.css'
import styles from './appStyles.module.css'
       - To use regular stylesheet in App.js
    <h1 className='error'>Error</h1>
       - To use module stylesheet in App.js
     <h1 className={styles.success}>Success</h1>
      - The advantage of using CSS modules is that the classes are locally scoped by default. For example if we copy regular style sheet inside Inline component it will work, so error class will work in App component and Inline component
      In CSS module stylesheet we are reference the class names using styles variable it cannot be used in children component, so if we copy success class in Inline component it will show compile error, so we cant use class to some other component 
4. CSS in JS libraries 


Lifecycle Methods
     When we create a react component the component goes through several stages in its lifecycle. React provides us with built in methods that we can override at particular stages in lifecycle 
     Lifecycle methods are available for class component and not available for functional component 

1. Mounting - 4 methods
      Mounting lifecycle methods are called when an instance of component is being created and inserted into the DOM
     - constructor
     - static getDerivedStateFromProps
     - render
     - componentDidMount
2. Updating - 5 methods
      Updating lifecycle methods are called when a component is being re-rendered as a result of changes to either its props or state
      - static getDerivedStateFromProps
      - shouldComponentUpdate
      - render
      - getSnapshotBeforeUpdate
      - componentDidUpdate
3. Unmounting - 1 method
      Unmounting lifecycle methods are called when a component is being removed from the DOM
      - componentWillUnmount
4. Error handling - 2 method
      Error handling lifecycle methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component 
     - static getDerivedStateFromError
     - componentDidCatch 

Component Mounting Lifecycle methods
      This methods are called when instance of method is called and inserted into the DOM

1. construtor(props)
     - It is special function that will get called whenever a new component is created 
     - Used for initializing state and binding the event handlers to class instance
     - What u shouldnt do in a constructor which cause side effects, for example u should never make HTTP requests from within a constructor 
     - We have to call special function called super inside constructor which calls base class constructor. In our component we have access to this.props only after we have initially called super passing in the props as an argument
     - Construtor is only place where we expected to change or set the state by directly overwriting this.state fields, in all other scenarios we have to use this.setState 

2. static getDerivedStateFromProps(props,state)
      - It is rarely used lifecycle method, it is used when state of the component depends on changes in props over time        - Consider we have a component but the initial state of the component depends on the props being passed to the component in such scenario we can use this method to set the state 
      - Since it is static method it does not have access to 'this' keyword, so we cannot call this.setState inside this particular method, instead we can just return an object that represents the new state of the component
      - We shouldnt do which cause side effect is fetching data from HTTP requests 

3. render()
      - only required method in class component 
      - In render() we simply read this.props, this.state and return JSX which describes the UI 
      - We shouldnt change the state of the component or interacting with the DOM or make ajax calls 
      - Since it is render() JSX which also contains the other children components right after the parent render method, the children components lifecycle methods are also executed 

4. componentDidMount()
       - This method will be called only once in the whole lifecycle of a given component and it is invoked immediately after a component and all its children components have been rendered to the DOM
       - This is perfect place where we can interact with the DOM or perform any Ajax calls to load data 

1. Create LifecycleA.js, using react snippet rce create class component and remove export from class
class LifecycleA extends Component {
    render() {
        return (
            <div>
                
            </div>
        )
    }
}

export default LifecycleA

2. Include LifecycleA.js inside App.js and import it
    <LifecycleA/> 

3. Use rconst to create new constructor and define name property within the state and initialize 
 constructor(props) {
        super(props)
    
        this.state = {
             name:'Senthil'
        }
        console.log('LifecycleA constructor')
    }

4. Next we create static method getDerivedStateFromProps which gets access to props and state as argument and has to return new state or null
static getDerivedStateFromProps(props,state){
        console.log('LifecycleA getDerivedStateFromProps')
        return null
    }

5. Next is render() which we already have and we will add console.log to track execution order
  render() {
        console.log('LifecycleA render')
        return (   
            <div>
               <h1>Lifecycle A</h1>   
            </div>
        )
    }

6. Next componentDidMount() and within body we just log to the console
    componentDidMount(){
        console.log('LifecycleA componentDidMount')
    }
Now when we run the appl, and check the browser console we can see first it prints constructor then getDerivedStateFromProps then render then componentDidMount, which is order of execution in mounting phase 

7. Now we see what happens if component has a child component 
Create LifecycleB.js and copy the code from LifecycleA and paste here and change LifecycleA to LifecycleB

8. Now we include LifecycleB component inside LifecycleA component 
 return (  
            <div> 
            <div><h1>Lifecycle A</h1></div>
            <LifecycleB/>
            </div>
        ) 
So we have LifecycleA as parent component and LifecycleB as child component 

9. Now when we run, we can see in console 
LifecycleA constructor
LifecycleA getDerivedStateFromProps
LifecycleA render
LifecycleB constructor
LifecycleB getDerivedStateFromProps
LifecycleB render
LifecycleB componentDidMount
LifecycleA componentDidMount

Component Updating Lifecycle Methods
     The methods are called when a component is being re-rendered because of changes to either props or state. We have 5 methods, out of that 3 falls into category of rarely used methods 

1. static getDerivedStateFromProps(props,state)
       This static method which receives props and state as its parameter and has to return either null or an object that represents the updated state of the component
       This method is called every time a component is rerender, used when the state depends on the props of the component. This method is rarely used methods in updating phase

2. shouldComponentUpdate(newProps, newState) - rarely used
      This method receives updated props and state, it dictates if at all the component should rerender or not, by default all class components will rerender whenever the props they receive or their state changes. This method can prevent that default behavior by returning false 
      We can compare the existing props and state values with the next props or state values and return true or false to let react know whether the component should update or not, so this method is used for performance optimization 

3. render()
     It is required method, used to read this.props, this.state and return JSX which describes UI
     Avoid changing the state or interacting with the DOM in render()

4. getSnapshotBeforeUpdate(prevprops,prevstate)-rarely used
        This method accepts previous props and previous state as its parameters and it is called right before the changes from the virtual DOM are to be reflected in the DOM 
        Used to capture some information from DOM, for example u can read the user's scroll position and after the update maintain that scroll position by performing some calculations 
        This method will either return null or return a value, the returned value will be passed as the 3rd parameter to the next method 
        Used to read the current DOM state and returns a value or not

5. componentDidUpdate(prevProps,prevState,snapshot)
        This method will be called after the render is finished in the rerender cycles (ie) we can be sure that the component and all its sub components have properly rendered itself after the update. This method accepts 3 parameters prevProps, prevState and snapshot value returned from getSnapshotBeforeUpdate(). This method is called only once in each rerender cycle 
      We can make Ajax calls but before making the call you need to compare the previous props with new props and then decide whether to make Ajax call or not, if u r not comparing you are making unwanted requests which is not good idea 
     componentDidUpadte called once after the component has rerender and they suitable to make Ajax calls based on previous and current props value

1. We use update lifecycle methods in LifecycleA.js, create shouldComponentUpdate()
    shouldComponentUpdate(){
        console.log('LifecycleA shouldComponentUpdate')
        return true
    }

2. Create getSnapshotBeforeUpdate and componentDidUpdate method

 getSnapshotBeforeUpdate(prevProps,prevState){
        console.log('LifecycleA getSnapshotBeforeUpdate')
        return null
    }

    componentDidUpdate(){
        console.log('LifecycleA componentDidUpdate')
    }

3. Inculde same 3 methods in LifecycleB component also 
    shouldComponentUpdate(){
        console.log('LifecycleB shouldComponentUpdate')
        return true
    }

    getSnapshotBeforeUpdate(prevProps,prevState){
        console.log('LifecycleB getSnapshotBeforeUpdate')
        return null
    }

    componentDidUpdate(){
        console.log('LifecycleB componentDidUpdate')
    }

4. Now to trigger an update lifecycle we need to change either the props or state. So in LifecycleA component we change the state on a button click 

<button onClick={this.changeState}>Change State</button>

5. Create changeState method where we change state property name 

changeState = () => {
      this.setState({
           name: 'Kirithik'
      })
}

When we run the appl, we can see all methods pertaining to the mounting phase are already executed
LifecycleA constructor
LifecycleA getDerivedStateFromProps
LifecycleA render
LifecycleB constructor
LifecycleB getDerivedStateFromProps
LifecycleB render
LifecycleB componentDidMount
LifecycleA componentDidMount
  
When we click the button, we can see update lifecycle methods are logged 
LifecycleA getDerivedStateFromProps
LifecycleA shouldComponentUpdate
LifecycleA render
LifecycleB getDerivedStateFromProps
LifecycleB shouldComponentUpdate
LifecycleB render
LifecycleB getSnapshotBeforeUpdate
LifecycleA getSnapshotBeforeUpdate
LifecycleB componentDidUpdate
LifecycleA componentDidUpdate   

We have LifecycleA getDerivedStateFromProps,shouldComponentUpdate,render after that execution passes on to child component we have LifecycleB getDerivedStateFromProps,shouldComponentUpdate,render. Once both child and parent components have been rendered we have slightly different order for getSnapshotBeforeUpdate and componentDidUpdate, first child component method is executed and then the corresponding parent component method is execute 

Unmounting Lifecycle method
    It has one method componentWillUnmount(), this method is invoked immediately before a component is unmounted and destroyed. In this method we can perform some clean up task like cancelling any network requests, removing event handlers, cancelling any subscriptions and also invalidating timers from setTimeout or setInterval()
    You should'nt do is calling setState method because the component is never rerendered after it has been rerendered 

ErrorHandling Lifecycle method
    It has 2 methods static getDerivedStateFromError(error) and componentDidCatch(error,info)  
    This methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component 

Fragments
   - Used to group list of children elements without adding extra nodes to the DOM

Example 1:
1. Create FragmentDemo.js, use react snippet rfce to create Functional component 
function FragmentDemo() {
    return (
        <div>
            Fragment Demo
        </div>
    )
}

export default FragmentDemo

2. Include FragmentDemo.js in App.js and import it
     <FragmentDemo/>

3. Now we want to convert text Fragment Demo to heading so we will replace <div> with <h1> tag. Next we add description using <p> tag 

function FragmentDemo() {
    return (
        <h1>
            Fragment Demo
        </h1>
        <p>This describes Fragment Demo</p>
    )
}

Now it will be showing an error saying "JSX expressions must have one parent element".
   So anytime ur component has to return multiple elements you have to enclose them in a single parent element, so we add <div> tag 
function FragmentDemo() {
    return (
        <div>
        <h1>
            Fragment Demo
        </h1>
        <p>This describes Fragment Demo</p>
        </div>
    )
}
Now the error will be rectified and inspect the element we can notice that we have the enclosing div tag included in DOM tree, so between the <div> tag from App component and <h1> tag from Fragment component, we have additional <div> tag, here only react fragments comes into picture 
   We can replace the extra <div> tag with react fragments and that will prevent the extra node from being added to DOM

4. In FragmentDemo component replace <div> tag with <React.Fragment> tag 

function FragmentDemo() {
    return (
        //<div>
        <React.Fragment>
        <h1>
            Fragment Demo
        </h1>
        <p>This describes Fragment Demo</p>
        </React.Fragment>
        // </div>
    )
}

Now when we run and inspect the element, we dont have <div> tag between App component <div> tag and <h1> tag  

Example 2:
1. Create Table.js, with rcfe react snippet, create a functional component and inside JSX replace <div> tag with <table> tag 
     Within <table> tag, create <tr> tag and within the row we want to render the columns and columns will be maintained in a separate component which is Column.js 
function Table() {
    return (
        <table>
            <tbody>
                <tr>
                    
                </tr>
            </tbody>
        </table>
    )
}

2. Create Columns.js, with rfce react snippet, create functional component and within <div> tag, add 2 columns using <td> tag 
function Columns() {
    return (
        <div>
            <td>Name</td>
            <td>Senthil</td>
        </div>
    )
}

export default Columns

3. Include Columns component inside Table component 

function Table() {
    return (
        <table>
            <tbody>
                <tr>
                    <Columns/>
                </tr>
            </tbody>
        </table>
    )
}

4. Include Table component in App.js and import it
     <Table/>

When we run the appl, we can see 2 columns in browser and in the browser console we can see warning as Validating DOM nesting, <td> cannot appear as child of <div>.
    When we inspect the element we can see in DOM tree <td> tag within <div> tag and <div> tag is necessary as we are returning multiple elements in JSX of Columns component. Now we can replace <div> tag with <React.Fragment> tag 

5. In Columns component, we replace <div> tag with <React.Fragment> tag 

function Columns() {
    return (
       /*  <div>
            <td>Name</td>
            <td>Senthil</td>
        </div> */
        <React.Fragment>
            <td>Name</td>
            <td>Senthil</td>
        </React.Fragment>
    )
}

When we run there is no warning in console and when we inspect we cant see <div> tag for <td> tag 

Pure Components
   We have been creating class components by extending the component class from React. There is another way to create component by extending the pure component class from React 

1. Create PureComponent.js with rpce react snippet, create class component which extends PureComponent and remove the export from class 

class PureComp extends PureComponent {
    render() {
        return (
            <div>
                Pure Component
            </div>
        )
    }
}

export default PureComp

2. Include PureComp inside App.js and import it
      <PureComp/>

3. Create regular component called RegComp.js with rce react snippet create a class component and remove export from class

class RegComp extends Component {
    render() {
        return (
            <div>
                Regular Component
            </div>
        )
    }
}

export default RegComp

4. Create parent component called ParentComp.js with rce react snippet, create class component and remove export from class 
class ParentComp extends Component {
    render() {
        return (
            <div>
                Parent Component 
            </div>
        )
    }
}

export default ParentComp

   - Create constructor with rconst and create new state property called name and initialize it to 'Senthil'
  constructor(props) {
        super(props)
    
        this.state = {
             name:'senthil'
        }
    }

   - Next we add componentDidMount() and within the body we create a timer using setInterval() with 2 arguments. First one is a function which is arrow function, inside that we call setState and set the name property to 'Senthil' again and second argument is an interval 
componentDidMount(){
        setInterval(()=>{
            this.setState({
                name:'senthil'
            })
        },2000)
    }

    - Now include RegComp and PureComp in JSX passing name as a prop 
            <div>
                Parent Component 
                <RegComp name={this.state.name}/>
                <PureComp name={this.state.name}/>
            </div>

5. Now include name prop in RegComp and PureComp
             <div>
                Regular Component {this.props.name}
            </div>
            <div>
                Pure Component {this.props.name}
            </div>

6. In App.js include ParentComp instead of PureComp and import it
      <ParentComp/>

7. When we run, it should display in browser as
Parent Component
Regular Component senthil
Pure Component senthil

8. Now add console.log in all the component to check how render method is called in all 3 components 
   When we run we can initially Parent component, Regular component and Pure Component, but after that every 2 secs the setState() is called which will rerender the parent component . If parent component rerenders then child component also rerenders unless u return false from shouldComponentUpdate. Every 2 secs parent and the regular component are rerendered but pure component is never rerendered 

Regular Component		   Pure Component
1. A regular component does     1. A pure component implement
not implement                   shouldComponentUpdate with a
shouldComponentUpdate method.    shallow props and state
It always returns true by        comparison
default

Shallow Comparison(SC)

1. Primitive types
     - For two primitive types A and B like numbers, string and boolean 
  A (SC) B returns true if A and B have the same value and are of same data type  
eg: string 'Senthil' (SC) string 'Senthil' returns true

2. Complex Types
       Complex types like objects and arrays 
A (SC) b returns true if A and B reference the exact same object 
var a={1,2,3}
var b={1,2,3}
var c=a
var ab_eq=(a===b); //false
var ac_eq=(a===c) //true

Pure Component
    A pure component implements shouldComponentUpdate with a shallow prop and state comparison. It does shallow comparison of previous state with current state and shallow comparison of previous props with current props and only when shallow comparison indicates there is a difference the component will rerender 

   In our example we are dealing with primitive types and props comparison, we are sending a prop which is of type string and has value of 'Senthil'. Every 2secs the pure component sees that previous props value of 'Senthil' is no different from the current prop value of 'Senthil' and hence does not render and because a regular component does not implement this check, it will always rerender 

9. Now we make ParentComp to extends PureComponent instead of Component 
   When we run the appl,we get in console as
Parent Component    
Regular Component
Pure Component
   We can see initial rendering of all components and after 2 sec there is no rerender, the parent component checks previous state with current state and see there is no difference so there is no rerender. So if parent dosent rerender then children also never rerender so we cant see any statement logged in 2sec interval 

Why PureComponents?
    Pure components will prevent unnecessary renders and give performance boost in certain scenarios. For example we are rendering a list of 50 items, by not rerendering them when it is not required they are going to have good performance

Memo
   Pure components will only rerender the class components when there is a difference in the shallow comparison of props and state which result in a performance improvement 
   Pure component work only with class based component, the same feature can be done in functional component using React.memo concepts where components capable of avoiding rerender when there is no change in props

1. Create MemoComp.js with rfce react snippet create a functional component and within function parenthesis we destructure the name prop and inside JSX render that name property 
function MemoComp({name}) {
    console.log('Rendering Memo Component')
    return (
        <div>
            {name}
        </div>
    )
}

export default MemoComp

2. In ParentComp, we comment RegComp,PureComp and include MemoComp

render() {
        console.log('*******ParentComponent*********')
        return (
            <div>
                Parent Component 
                <MemoComp/>
                {/* <RegComp name={this.state.name}/>
                <PureComp name={this.state.name}/> */}
            </div>
        )
    }

We have setInterval() in componentDidMount() which basically calls setState() every 2secs resulting in rerender of the parent component 

3. Since name prop is not really changing every 2sec, we can gain performance improvement by not rerendering MemoComp 
   <MemoComp name={this.state.name}/>

4. So when ParentComp rerenders MemoComp also rerenders, but name prop is going to stay the same with every rerender. So we need a way to avoid rerender Memo functional component and we can use React.Memo
   React.Memo is introduced in version 16.6 or above. So in MemoComp.js use React.memo 

export default React.memo(MemoComp)

5. When we run the appl, it will display the initial rendering of Parent Component and Memo component and after 2 sec it will rerender only parent component 


Refs in React
   - Used to access DOM nodes directly within react
   - Suppose we have login form as soon as page is loaded, by default we want username input field to be focused, we see how to do it using refs

Way 1:
1. Create RefsDemo.js with rce react snippet, create class component and remove export from class 

2. Include RefsDemo component in App.js and import it
      <RefsDemo/>
So we can see textbox in browser, now we want this input field to be focused using refs

3. Create constructor using rconst, within the constructor create new property inputRef and to this property we assign React.createRef()
    constructor(props) {
        super(props)
        this.inputRef=React.createRef()
    }

4. Attach this ref to our input element in render() using ref attribute 
   <input type="text" ref={this.inputRef}/>
Now we have reference to input element

5. To check what does this.inputRef hold after reference is created, for that we create componentDidMount()
    componentDidMount(){
        console.log(this.inputRef)
    }
When we run, we see in console a property 'current' of type input which points to actual DOM node. To focus on the input element in componentDidMount we simply call focus() on current property
    componentDidMount(){
        this.inputRef.current.focus()
        console.log(this.inputRef)
    }
Now we can see on page load the input element has focus 

6. Next usecase of ref is to fetch the input value. Now create a button with onClick event 

  <button onClick={this.clickHandler}>Click</button>

  clickHandler=() => {
        alert(this.inputRef.current.value)
    }
 
Now when we give value in textbox and click button we can get the value

Way 2:
  React also provide a way to set refs using callback ref

1. Create a property cbRef and assign a value null
2. We create a method that will assign a DOM element to the previously created ref
constructor(props) {
        super(props)
        this.inputRef=React.createRef()
        this.cbRef=null
        this.setCbRef =  element =>{
            this.cbRef=element
        }
    }

3. Now attach the ref to the input element 
 <input type="text" ref={this.setCbRef}/>

4. In componentDidMount(), react will call ref callback with DOM element when component mounts and call it will null when it unmounts, that is the reason it is important to check whether the value exists on the reference property and not null

 componentDidMount(){
        if(this.cbRef){
            this.cbRef.focus()
        }
       // this.inputRef.current.focus()
       // console.log(this.inputRef)
    }

When we run, it will focus on the input element

Refs with class components
    Previously we add ref to normal HTML element like input element, it is also possible to add ref to class component 

1. Create Input.js with rce react snippet, create class component and in JSX we add <input> element
class Input extends Component {
    render() {
        return (
            <div>
                <input type="text"/>
            </div>
        )
    }
}

export default Input

2. Create ref using createRef() inside constructor
   constructor(props) {
        super(props)
        this.inputRef=React.createRef()
    }

3. Attach ref to input element
    <input type="text" ref={this.inputRef}/>

4. We can focus on input element in componentDidMount,but here we want to create a method that will in turn focus the input element and that method will be called by parent component 
    focusInput(){
        this.inputRef.current.focus()
    } 

5. Create FocusInput.js with rce react snippet create class component and remove export 
   Here we include Input.js component that we created and also create a button 

class FocusInput extends Component {
    render() {
        return (
            <div>
                <Input/>
                <button>Focus Input</button>
            </div>
        )
    }
}

export default FocusInput

When we click the button in parent component, the input element in child component should receive the focus and we achieve that using ref on this input component 

6. In FocusInput.js we create ref using createRef()
    constructor(props) {
        super(props)
        this.componentRef=React.createRef()
    }

7. Attach the ref to Input component
    <Input ref={this.componentRef}/>

8. Add clickHandler to button and within clickHandler called child component method using ref
  <button onClick={this.clickHandler}>Focus Input</button>

 clickHandler = () =>{
        this.componentRef.current.focusInput()
    }

9. Add FocusInput.js in App component and import it
     <FocusInput/>
When we run the appl and click the button, the focus will go to input element


Forwarding Refs
     It is technique for automatically passing a ref through a component to one of its children

1. Create FRInput.js with rfce react snippet, create functional component and within JSX add input element
function FRInput() {
    return (
        <div>
            <input type="text"/>
        </div>
    )
}

export default FRInput

2. Create FRParentInput.js with rce react snippet, create class component and remove export from class, include FRInput component and button
class FRParentInput extends Component {
    render() {
        return (
            <div>
                <FRInput/>
                <button>Focus Input</button>
            </div>
        )
    }
}

export default FRParentInput

3. Include FRParentInput inside App.js and import it
     <FRParentInput/>
When we run you should be able to see input and button. Here when we click on the button in parent component, the input in child component should receive focus, so we use forwrding ref  technique to allow the parent component to directly reference the native input element 

4. Create ref in FRParentInput constructor 
  constructor(props) {
        super(props)
        this.inputRef=React.createRef()
    }

5. Now attach the ref to child component using the ref attribute 
    <FRInput ref={this.inputRef}/>

6. We need to forward this ref to input element in child component using forwardRef() in React.
   In FRInput.js we modify how we create functional component , to forward ref we use React.forwardRef() which takes component as its parameter 
   We know every functional component receives props as its parameter, but when component is passed as a parameter to createRef() it receives the ref attribute as its second parameter. We use this ref parameter and pass it as value to ref attribute on the native input element. So on the input element ref attribute and assign the value of ref parameter, this ref parameter will point to the value of ref attribute from parent component (ie) ref is being forwarded from the parent component to native input element
const FRInput = React.forwardRef((props,ref) => {
    return (
        <div>
            <input type="text" ref={ref}/>
        </div>
    )
})

7. In FRParentInput.js we can define clickHandler for button
 <button onClick={this.clickHandler}>Focus Input</button>

 clickHandler = () => {
        this.inputRef.current.focus()
    }
    
When we run and click button, the input element get focus

React Portals
     - React portals provide a way to render children into DOM node that exists outside the DOM hierarchy of the parent component
     - So far we have one DOM element in our HTML that we were mounting the react application.
     In public folder and in index.html we can see <div> element with id='root' and in index.js file we use ReactDOM.render() and mount our App component on to root element
     So in DOM tree every single react component in our application falls under root element with <div id='root'>
    - React portals provide the ability to break out of this DOM tree, so you can render a component onto DOM node that is not under this root element 

1. Add DOM node that falls outside the root element, so in index.html below <div id="root"></div> we add
     <div id="portal-root"></div>

2. Create PortalDemo.js with rfce react snippet, create functional component 
function PortalDemo() {
    return (
        <h1>
           Portal Demo 
        </h1>
    )
}

export default PortalDemo

3. Include PortalDemo in App.js and import it
      <PortalDemo/>
When we run and inspect we can see that element falls under the root element and not under portal-root element 

4. We use ReactDOM.createPortal() to insert this component under portal-root node, so in PortalDemo.js 
    - import ReactDOM 
         import ReactDOM from 'react-dom'
    - ReactDOM.createPortal() takes 2 parameter, first parameter is JSX which u want to render (ie) <h1> tag and second parameter is DOM node to mount the element (ie) portal-node

function PortalDemo() {
    return ReactDOM.createPortal(
        <h1>
           Portal Demo 
        </h1>,
        document.getElementById('portal-root')
    )
}
When we run and inspect the element, we can see <h1> tag ill be under portal-root DOM node
    So in ur react appl even though all the components are children to app component and the app component is mounted onto the root DOM node, it is possible to break away from that and mount on any DOM node that you wish to using react portals 

Why Portals?
   - One of use case is having to deal with parent component CSS when that child component is modal or popup or tooltip 

https://codesandbox.io/s/00254q4n6p
    - Here since we use portal, modal will be comes inside the <div> tag, but if we remove portal then modal will comes out of <div> tag 

Error Handling Phase methods
      React lifecycle has error handling phase which includes 2 lifecycle methods 
    1. static getDerivedStateFromError(error)
    2. componentDidCatch(error,info)
      - We see that runtime errors during rendering could put our appl in broken state, react basically unmount the whole react component tree. Now we want to catch error in the component tree and display fallback UI, this is where we use error boundaries

Error Boundary
    - A class component that implements either one or both of the lifecycle methods getDerivedStateFromError or componentDidCatch becomes an error boundary
    - The static method getDerivedStateFromError method is used to render a fallback UI after an error is thrown and the componentDidCatch method is used to log error information 

1. Create Hero.js with rfce react snippet, create functional component and this component will accept heroName as a prop and will render the same
   To understand error boundary we need to throw an error so if heroName is 'Joker' then throw an error
function Hero ({ heroName }) {
    if (heroName === 'Joker') {
      throw new Error(' Not a hero!')
    }
    return <h1>{heroName}</h1>
}

export default Hero

2. We add two Hero component in App.js with different heroName
      <Hero heroName='Batman'/>
      <Hero heroName='Superman'/>
Now we can see both the heros in browser

3. Now we pass another hero Joker in App.js
      <Hero heroName='Joker'/>
When we save, u can see in browser the entire appl crashes 

4. We want is if a particular component throws an error, only that component shoukd fallback into UI and remaining components should be unaffected 
   - Create ErrorBoundary.js with rce react snippet, create class component and remove export from class
class ErrorBoundary extends Component {
    render() {
        return (
            <div>
                
            </div>
        )
    }
}

export default ErrorBoundary

   - To become an error boundary we have to define getDerivedStateFromError or componentDidCatch lifecycle methods 
   - getDerivedStateFromError it receives error as parameter and within the body we return new state object, so we set a property 'hasError' to true 
    static getDerivedStateFromError(error){
        return {
            hasError:true
        }
    }
   - Since we dont have hasError state, we create in constructor and initialize it 
       constructor(props) {
        super(props)
        this.state = {
             hasError:false
        }
    }
If at all there is an error when rendering any of the components, we are setting the state hasError property to true, this state property is used to create a fallback UI 
      - So in render(), if hasError is true then we return some text and if no error then return this.props.children which refer to the component which actually rendering 
     render() {
       if(this.state.hasError){
           <h1>Something went wrong</h1>
       }
       return this.props.children
    }

5. Now wrap the components with this error boundary, so in App.js
     <ErrorBoundary>
         <Hero heroName='Batman'/>
         <Hero heroName='Superman'/>
         <Hero heroName='Joker'/>
      </ErrorBoundary>

When we save and see the browser, still we will get error. React team have mentioned that error boundaries are primarily useful for production but in development they want to make errors highly visible as possible, so we always see this error during development 
    On top right click close button we now have our appl back with fallback message 

6. To log error information in console
    componentDidCatch(error, info) {
		console.log(error)
		console.log(info)
	}

Higher Order Component

Why we need higher order Component?
1. Create ClickCounter.js with rce react snippet, create class component and remove export from class and in JSX create a button 
class ClickCounter extends Component {
    render() {
        return (
            <div>
                <button>Clicked X times</button>
            </div>
        )
    }
}

export default ClickCounter

2. Include ClickCounter in App.js and import it 
      <ClickCounter/>

3. Create constructor with rconst and creating state property called count and initialize it to zero
constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }

4. Create click event for the button 
<button onClick={this.incrementCount}>Clicked X times</button>

5. Create incrementCount() and within the body, we call setState() to increment count value by 1, since we need previous state to increment the value, the argument to setState() will not be simple object instead it takes a function which gets previous state as a parameter and returns the new state 

    incrementCount = () => {
       this.setState(prevState => {
           return { count : prevState.count + 1}
       })
    }

6. Finally in render() we extract count from the state and include it in JSX
 render() {
        const {count}=this.state 
        return (
            <div>
                <button onClick={this.incrementCount}>Clicked {count} times</button>
            </div>
        )
    }

When we save and look the browser, when we click the button the count value increments. But the client now comes up with a new requirement that another UI which works very similar to click counter, instead of button clicks we want a heading which indicates the number of times you hover over it. So basically click counter with click functionality is replaced by hover functionality

7. Create HoverCounter.js with rce react snippet, create class component and remove export from class and in heading we handle onMouseOver event with incrementCount()
class HoverCounter extends Component {
    render() {
        return (
            <div>
               <h2 onMouseOver={this.incrementCount}>Hovered X times</h2> 
            </div>
        )
    }
}

export default HoverCounter

8. Now we need counter functionality and that was already implemented in ClickCounter.js, we just copy and paste constructor and incrementCount()
 constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }
    
    incrementCount = () => {
       this.setState(prevState => {
           return { count : prevState.count + 1}
       })
    }

9. Now in render(), we extract count value and display it as part of heading tag
  render() {
        const {count} = this.state
        return (
            <div>
               <h2 onMouseOver={this.incrementCount}>Hovered {count} times</h2> 
            </div>
        )
    }

10. Include HoverCounter.js in App.js and import it 
      <HoverCounter/>
When we save and look the browser, so we hover on heading the count value will increment 

11. Now client have another requirement that an input element that counts the number of key presses, so we can implement by using clickCounter or HoverCounter and we understand that we are duplicating the code and not really reusing our functionality. So if 10 different components needed a counter functionality we would writing the same code over and over again. So there is a need to share common functionality between components without repeating code and there is where concept of Higher Order components comes into picture 

What is Higher Order Components?
    - It is a pattern where a function takes a component as an argument and returns a new component 
   const newComponent = higherOrderComponent(originalComponent)
    - Typically HOC adds an additional data or functionality to the original component so new component can also be referred to as enhanced component
   const enhancedComponent = higherOrderComponent(originalComponent)
   So HOC have a function which accepts original component adds functionality and returns enhanced component 

1. Create withCounter.js
      - import React 
          import React from 'react'
      - Create hoc function which is arrow function and accepts original component as parameter and returns new component. So within the body create a NewComponent and in render() we return original component and finally return NewComponent in arrow function. So we have HOC which is a function that accepts original component and returns new component 
   - This HOC dosent add anything to original component, so we add prop called name as "Senthil' and finally export it 

import React from 'react'

const UpdatedComponent = OriginalComponent => {
    class NewComponent extends React.Component {
       render() {
           return <OriginalComponent name='Senthil'/>
       }
    }
      return NewComponent
} 

export default UpdatedComponent

2. Now we apply HOC pattern to ClickCounter and HoverCounter. So we import UpdatedComponent from withCounter and while exporting we will call UpdatedComponent function passing in ClickCounter component,similarly use for HoverCounter

import UpdatedComponent from './withCounter'

export default UpdatedComponent(ClickCounter)
export default UpdatedComponent(HoverCounter)

So here instead of exporting ClickCounter and HoverComponent we export Higher order component 

3. Now HOC in addition to ClickCounter or HoverCounter now has new prop called name, so in both the components we can actually render this prop 

<button onClick={this.incrementCount}>{this.props.name} Clicked {count} times</button>

<h2 onMouseOver={this.incrementCount}>{this.props.name} Hovered {count} times</h2> 

When we save and look at browser we can see the prop being rendered in button and heading, so our hoc injects a named prop to any component required 

4. But we need counter functionality to be shared by the components, so we copy constructor and incrementCount to HOC, so NewComponent now maintains a count state and a method to increment that state, this is the common functionality we want to share

const UpdatedComponent = OriginalComponent => {
    class NewComponent extends React.Component {
        constructor(props) {
            super(props)
        
            this.state = {
                 count:0
            }
        }
        
        incrementCount = () => {
           this.setState(prevState => {
               return { count : prevState.count + 1}
           })
        }
       render() {
           return <OriginalComponent name='Senthil'/>
       }
    }
      return NewComponent
} 

5. Now we remove constructor and incrementCount method from both ClickCounter and HoverCounter, this will avoid duplication of code 

6. Now in HOC we need to pass down the state and incrememtCount() as props so that originalComponent can make use of that functionality 
 render() {
           /* return <OriginalComponent name='Senthil'/> */
           return <OriginalComponent count={this.state.count} incrementCount={this.incrementCount}/>
       }
Now we can make use of these props in ClickCounter and HoverCounter 

7. In ClickCounter.js, we are going to destructure count and incrementCount from this.props and remove the state 

       render() {
            const {count, incrementCount} = this.props
            return (
                <button onClick={incrementCount}>Clicked {count} times</button>
            )
        }

        render() {
        const {count, incrementCount} = this.props
        return (
            <h2 onMouseOver={incrementCount}>Hovered {count} times</h2> 
        )
       }
When we save and look at the browser we can see both the counter components are working as before but we are reusing code rather than duplicating code 

    In App.js, we have included ClickCounter component which is defined in ClickCounter.js, here we are exporting the UpdatedComponent HOC passing in the ClickCounter. UpdatedComponent is a function which accepts originalComponent as parameter and returns a NewComponent, in our case OriginalComponent refers to ClickCounter 
    NewComponent has functionality to maintain the state of count property and also method to increment that count property, both of them are passed as props to OriginalComponent, the OriginalComponent enhanced with these props are then returned
    Now control goes back to ClickCounter where the count and incrementCount props passed in from HOC are destructured and used in the return statement, when u click on button the count is incremented and displayed in UI. The same execution flow also happens for the HoverCounter component, both the components separating the state, incrementing the count in ClickCounter will not affect the HoverCounter and viceversa

HOC Naming Conventions
    - Function and filename should be same, so we change UpdatedComponent as withCounter
    - OriginalComponent is usually referred to WrappedComponent 
    - NewComponent will be same as function name but with Pascal case(ie) WithCounter 

8. Passing down props to HOC 
      - In App.js, we will pass prop name on ClickCounter component 
     <ClickCounter name='Senthil'/>
      - Now in ClickCounter we will render that name prop 
     <button onClick={incrementCount}>{this.props.name} Clicked {count} times</button>
   When we save and run the appl, name wont be displayed in browser in HOC, when we specify props in ClickCounter component, the props are sent down to HOC and not to ClickCounter 
     - So we pass remaining props using Spread operator 
return <WrappedComponent count={this.state.count} incrementCount={this.incrementCount} {... this.props} />

9. Passing parameters to HOC function, in our case instead of incrementing the count value by 1, we want to increment it by different numbers for both the counter component we can do by passing parameter to HOC function
   - Now arrow function will have 2 parameters, first is WrappedComponent and second is incrementNumber value
    const withCounter = (WrappedComponent, incrementNumber) => {
   - Instead of increment by 1 we now increment by incrementNumber 
 incrementCount = () => {
            this.setState(prevState => {
                return { count : prevState.count + incrementNumber}
            })
         }
   - Now in ClickCounter and HoverCounter pass the second argument 

export default withCounter(ClickCounter,5)

export default withCounter(HoverCounter,5)

When we save and look at browser, the count value will be increment by 5 

Render Props
    - Also used to share code between components 

Why Render Props?
1. Create ClickCounter2.js with rce react snippet, create class component and remove export from class and in JSX add button
   Create constructor with state property called count and initialize to 0 and add clickHandler to button and increment the state by 1 

class ClickCounterTwo extends Component {
    constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }

    incrementCount = () => {
        this.setState(prevState => {
            return {count:prevState.count + 1}
        })
    }
    
    render() {
        const {count}=this.state
        return (
           <button onClick={this.incrementCount}>Clicked {count} times</button>
        )
    }
}

export default ClickCounterTwo

2. Include ClickCounterTwo in App.js and import it
    <ClickCounterTwo/>
When we save and look browser, we can button and when we click, it increments the value

3. Now we add new requirement of same functionality for HoverCounter, create HoverCounterTwo.js with rce react snippet create a class component 

class HoverCounterTwo extends Component {
    constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }

    incrementCount = () => {
        this.setState(prevState => {
            return {count:prevState.count + 1}
        })
    }
    
    render() {
        const {count}=this.state
        return (
            <h2 onMouseOver={this.incrementCount}>Hovered {count} times</h2>
        )
    }
}

export default HoverCounterTwo

4. Include HoverCounterTwo in App.js and import it
     <HoverCounterTwo/>

5. Now client have another requirement that an input element that counts the number of key presses, so we can implement by using clickCounter or HoverCounter and we understand that we are duplicating the code and not really reusing our functionality.So there is a need to share common functionality between components without repeating code and there is where concept of Render Props comes into picture

6. Create User.js with rce react snippet, create class component and remove export from class 
class User extends Component {
    render() {
        return (
            <div>
                Senthil
            </div>
        )
    }
}

export default User

7. Include User.js inside App.js and import it
      <User/>
When we save and look at browser, we can see text 

8. Instead of hardcoding 'Senthil' in User.js we will pass it as props, so in App.js 
       <User name='Senthil'/>
   - In User component we will render this props
class User extends Component {
    render() {
        return (
            <div>
               {this.props.name}}
            </div>
        )
    }
}
When we save and look at browser, we can see text 'Senthil'

9. Instead of passing string 'Senthil' as name props, we want to pass function which will return String 'Senthil'
    <User name={() => 'Senthil'} />
   - In User.js, inorder to display 'Senthil' we need to call the function 
      {this.props.name()}
When we save and look at browser, we can see text 'Senthil'

10. We want to have parameters to function in name prop, based on the parameter we want to change what is rendered by User component
    - So in App.js we pass isLoggedIn as a parameter and the function will return 'Senthil' or 'Guest' based on value of isLoggedIn 
   <User name={(isLoggedIn) => isLoggedIn ? 'Senthil':'Guest'} />
    - Now in User.js, name prop will accept an argument which we will pass as true, which means isLoggedIn is true so 'senthil' is rendered in browser, if we change to false then 'Guest' will render in browser  
     {this.props.name(true)}
When we save and look at browser, we can see text 'Senthil'

11. In App.js, we can change name prop to render 
<User render={(isLoggedIn) => isLoggedIn ? 'Senthil':'Guest'} />
   - In User.js, we change 
      {this.props.render(true)}

This is valid and never conflict with render lifecycle method, When we save and look at browser, we can see text 'Senthil'

   So in React, it is possible to use prop whose value is a function to control what is actually rendered by a component since Render Props is based on 

What is Render Props?
    It refers to a technique for sharing code between components using a prop whose value is a function.
    We have common code in ClickCounterTwo and HoverCounterTwo, so how we can share code by using render props pattern

1. Create RenderPropsCounter.js with rce react snippet, create class component and remove export from class
   This Counter component is container component where we implement common functionality (ie) state and incrementCount(). So copy constructor and incrementCount() from ClickCounterTwo and paster in Counter component
class RenderPropsCounter extends Component {
    constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }

    incrementCount = () => {
        this.setState(prevState => {
            return {count:prevState.count + 1}
        })
    }
    render() {
        return (
            <div>
                
            </div>
        )
    }
}

export default RenderPropsCounter

JSX is empty because render props is going to control what will be rendered by this counter component. In our example we will render ClickCounterTwo and HoverCounterTwo and pass down count state and incrementCount()

2. Remove constructor and incrementCount() from ClickCounterTwo and HoverCounterTwo

3. In RenderPropsCounter.js, we provide JSX as 
render() {
        return (
            <div>
               {this.props.render(this.state.count,this.incrementCount)} 
            </div>
        )
    }

4. Include RenderPropsCounter.js in App.js and import it, we are going to add rendered prop whose value is a function and it receives count, incrementCount and will return ClickCounterTwo and passing same as props
     <RenderPropsCounter render={(count,incrementCount) => (<ClickCounterTwo count={count} incrementCount={incrementCount} /> )}
/>
        <RenderPropsCounter render={(count,incrementCount) => (<HoverCounterTwo count={count} incrementCount={incrementCount} /> )}
/>

5. In ClickCounterTwo, we will destructure count and incrementCount 
   render() {
        const {count, incrementCount}=this.props
        return (
           <button onClick={incrementCount}>Clicked {count} times</button>
        )
    }
Repeat the same for HoverCounterTwo component also 

When we save and look browser, it is working as expected

So in App component we have RenderPropsCounter component which have count state and incrementCount(), this RenderPropsCounter component does not render anything on its own, it is going to render whatever is passed as the render prop and while doing so it passes count state, incrementCount (). So renderprop is ClickCounterTwo component so count state and incrementCount from RenderPropsCounter component are passed as props to ClickCounterTwo component. ClickCounterTwo  component makes use of passed in props to render the actual UI 
    When u click on button and call incrementCount() or try to display the count value it is what the RenderPropsCounter component has provided. Even though they share same code the RenderPropsCounter component instance is different and hence there is no conflict between count state values
    prop is need not called as render, u can call anything but render is kind of convention. Even Render prop dosent make use of prop instead the children prop is used
   - Instead of render we pass in function inbetween the component opening and closing tags 

<RenderPropsCounter> 
   {(count,incrementCount) => (
         <ClickCounterTwo count={count} incrementCount={incrementCount} /> 
    )}
</RenderPropsCounter>
<RenderPropsCounter> 
   {(count,incrementCount) => (
         <HoverCounterTwo count={count} incrementCount={incrementCount} /> 
    )}
</RenderPropsCounter>

   - In RenderPropsCounter.js, instead of using render() we use children()
 {this.props.children(this.state.count,this.incrementCount)}


React Formik 

Forms
    - Forms are a vital part of any business application, we use forms to register, login, submit a request etc 
    - Used to handle form data, validation, visual feedback with error messages and Form submission

Formik
   - Formik is a small library that helps u to deal with forms in React and React Native

Why Formik?
   It has 3 main parts
     - Managing form data (ie) getting the values of the form  fields in and out of form state 
     - Easily handle form submission
     - Form validation and displaying error messages

Formik will do in scalable performant and easier way 

Prerequisites
  - HTML, CSS, Javascript + ES6, React Hooks 

Building Simple Forms
    - Form has 3 fields name, email and channel with submit button
    - Our goal is to implement 3 things - Managing Form state, Handling Form submission and Validation error messages

1. Create react project
    >npx create-react-app react-formik-demo

2. In App.js remove the complete header tag, as of now we have
    <div className="App">
    </div>

3. Create new folder components within src folder 

4. Create YoutubeForm.js with rfce react snippet, create functional component 

5. Now we create basic HTML form inside JSX 

<div>
   <form>
      <label htmlFor='name'>Name</label>
      <input type='text' id='name' name='name' />

      <label htmlFor='email'>Email</label>
      <input type='email' id='email' name='email' />

      <label htmlFor='channel'>Channel</label>
      <input type='text' id='channel' name='channel' />

      <button>Submit</button>
   </form>
</div>

6. In App.css, remove everything and we apply our css 

.App {
  display: flex;
  justify-content: center;
}

label {
  font-weight: bold;
  display: flex;
  margin-bottom: 5px;
}

input[type='text'],
input[type='email'],
textarea {
  display: block;
  width: 400px;
  padding: 6px 12px;
  font-size: 14px;
  line-height: 1.42857143;
  color: #555;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ccc;
  border-radius: 4px;
  /* margin-bottom: 20px; */
}

.form-control {
  margin-bottom: 20px;
}

.error {
  color: red;
}

7. Include YoutubeForm.js inside App component and import it
      <YoutubeForm/>
When we save and run, u can see form in broswer wth 3 fields and button 

8. Install formik
    React-formik-demo>npm add formik
Now we can use formik library

9. Import hook called useFormik to use formik library
         import {useFormik} from 'formik'

10. Basically hook is a function so we need to call it in our component using useFormik() which takes an object as its parameter and return an object which contains variety of useful properties and methods that we can use with our forms 
    const formik = useFormik({})
This formik help us to do 3 things (ie)managing Form state, Handling Form submission and Validation error message

11. Managing Form state
       We know our form have 3 fields so when we type something the value of the field changes and in react if value changes we need a state variable for name, email and channel or collectively we call that as form state 
      Form state is an object which maintains the value of the different form fields. If we change name to 'ram' it should be reflected in form state object and similarly for others. If we able to manage this form state we can eventually submit the data when the user clicks on submit button 
Step 1:
   To pass in a property called initialValues in the object we pass to useFormik hook. initialValues is an object which contains initial values for all our form fields, which contain name attribute of individual fields 
   const formik = useFormik({
       initialValues : {
             name: '',
             email: '',
             channel: ''
       }
    })

Step 2:
   We need to add onChange and value prop for each of form fields, this is required to ensure the form fields are tracked in react by formik
     handleChange() is formiks helper to update the value object 
    <form>
      <label htmlFor='name'>Name</label>
      <input type='text' id='name' name='name' onChange={formik.handleChange}
                 value={formik.values.name}/>

      <label htmlFor='email'>Email</label>
      <input type='email' id='email' name='email' onChange={formik.handleChange}
                 value={formik.values.email} />

      <label htmlFor='channel'>Channel</label>
      <input type='text' id='channel' name='channel' onChange={formik.handleChange}
                 value={formik.values.channel} />

      <button>Submit</button>
   </form>
Once we do this, formik will automatically track the form field values for you.
   Before return statement give 
      console.log('Form values',formik.values), to track the form values   

When we save and see the browser and input the values in textbox, it will be displayed in console  

12. Handling form submission 
      To handle form submission in formik using 2 steps

Step 1:
   - We need specify onSubmit handler on <form> tag, so formik provide with helper method called handleSubmit 
   <form onSubmit={formik.handleSubmit}>

   </form>

Step 2:
   We need to revist the object we pass in to useFormik hook, apart from initialValues we can specify another property called onSubmit contains a method which automatically receives the form state as its argument 
   So we write arrow function and within the function body we will print the values. So when u click submit button, formik will automatically execute onSubmit method 
  const formik = useFormik({
       initialValues : {
             name: '',
             email: '',
             channel: ''
       },
       onSubmit: values => {
           console.log('Form data',values)
       }
    }) 
When we save and look the browser, we fill the textbox and when u click submit, the form data will print in console 

Step 3:
   But in browser console we can see a warning, in order to get rid of that message we use
    <button type='submit'>Submit</button> 

When we save and look the browser, we fill the textbox and when u click submit, the form data will print in console and warning will disappear  

13. Validation form
Step 1:
   We need to define validation function and needs to assigned to a property called validate in the object that we pass to useFormik hook
   Now we specify 3rd property called validate which is a function which automatically receives the values object as its argument. We are going to have arrow function where we get access to the values 
   Validate function is a function that must satisfy some conditions for formik to work as intended. First condition is that this function must return an object so we create new object called error and return the same. Second condition is the keys of this error object should be similar to that of values object. Third condition is value of keys should be string indicating what the error message should be for that particular field 

const formik = useFormik({
       initialValues : {
             name: '',
             email: '',
             channel: ''
       },
       onSubmit: values => {
           console.log('Form data',values)
       }
       validate: values => {
   const errors = {}

   if (!values.name) {
     errors.name = 'Required'
   }

  if (!values.email) {    
      errors.email = 'Required'
   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
     errors.email = 'Invalid email format'
   }

   if (!values.channel) {
     errors.channel = 'Required'
   }

   return errors
 }
    }) 

Step 2:
   In order to make readability of useFormik code, so move them top of the function

const initialValues = {
  name: 'Vishwas',
  email: '',
  channel: ''
}

const onSubmit = values => {
  console.log('Form data', values)
}

const validate = values => {
   const errors = {}

   if (!values.name) {
     errors.name = 'Required'
   }

   if (!values.email) {
     errors.email = 'Required'
   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
     errors.email = 'Invalid email format'
  }

   if (!values.channel) {
     errors.channel = 'Required'
   }

   return errors
 }

And useFormik code can be changed as 

const formik = useFormik({
    initialValues,
    onSubmit,
    validate
  })

14. Displaying error messages
       We know formik object returned by useFormik contains a lot of useful properties and helper methods to manage our form and get hold of the error messages 
       Formik provides formik.values contains key value pairs for each of the form fields. Formik also provides another property called 'errors' with key value pairs for each of the form fields. So basically formik runs the validate function on change of form and then populate formik.errors object 

Step 1:
   Under each input element, add <div> tag that displays the error message and also display error message only if it exists so we need conditional render 

{formik.errors.name ? <div className='error'>{formik.errors.name}</div> : null }
{formik.errors.email ? <div className='error'>{formik.errors.email}</div> : null }
{formik.errors.channel ? <div className='error'>{formik.errors.channel}</div> : null }

When we save and look at browser and we can see the error messages

15. Visited fields
       Our validation function runs for each key stroke against the entire forms and our errors object contains all validation errors at any give moment 
       We dont want to display error messages for all fields if the user is interacted with only first field, so we want to display error message only if user is done typing in that field
       In order to keep track of the visited field in the form we need to add onBlur and pass formik.handleBlur method.
        onBlur={formik.handleBlur}
 In order to store that information formik use object called 'touched', it maintains key for every field and render error messages only if the field error message exists and the user has visited that particular field   

  {formik.touched.name && formik.errors.name ? (
          <div className='error'>{formik.errors.name}</div>
        ) : null}
      {formik.touched.email && formik.errors.email ? (
          <div className='error'>{formik.errors.email}</div>
        ) : null}
    {formik.touched.channel && formik.errors.channel ? (
          <div className='error'>{formik.errors.channel}</div>
        ) : null}

It will display message only if the field has been visited and error message exists 

When we save and run we cant see any error message, but if u keep cursor in the field and we take the cursor then only error message will display 

16. Alternative way to do validation
        This alternate way depends on library called 'Yup'

1. Install Yup
      React-formik-demo> npm add yup

2. Import yup in form
     import * as Yup from 'yup'

3. We need to write validation schema object
     - we create a constant validationSchema and we assign with yup object schema and we need to pass an object which contains the rules for each of our form fields 
 const validationSchema = Yup.object({
  name: Yup.string().required('Name is Required'),
  email: Yup.string()
    .email('Invalid email format')
    .required('Email is Required'),
  channel: Yup.string().required('Channel is Required')
})
    - Pass this schema into useFormik hook 
   const formik = useFormik({
    initialValues,
    onSubmit,
    validationSchema
   })

When we save and run we cant see any error message, but if u keep cursor in the field and we take the cursor then only error message will display 

17. Reduce boilerplate code

1. Copy the same code from YoutubeForm.js and create new form OldYoutubeForm.js and paste it

2. In YoutubeForm.js now we use formik concept in order to reduce boilerplate code. In all 3 props onChange, onBlur and  value are similar, there is some boilerplate code for every field in this form 
    Formik provides with helper method called getFieldProps() which behind the scenes will add this props for you, so replace 3 lines of code with single line called formik.getFieldProps('name') and also for helper method we need to add spread operator
   {...formik.getFieldProps('name')}
   {...formik.getFieldProps('email')}
   {...formik.getFieldProps('channel')}
When we save and run we cant see any error message, but if u keep cursor in the field and we take the cursor then only error message will display 

19. Formik Components
      Previously we use getFieldProps() to remove some boilerplate code but still we have to manually pass each input to getFieldProps helper method. Formik provide few components that implicitly use react context to make our code less verbose like Formik, Form, Field, ErrorMessage 

1.Formik Component 
     It is replacement to useFormik hook, the argument which we passed to useFormik as an object will be passed as props to Formik component

Step 1: Import Formik instead of useFormik
     import {Formik} from 'formik'

Step 2: we remove useFormik code

Step 3: We wrap our entire <form> tag with <Formik> tag 

Step 4: Pass different props to Formik component 
 <Formik
      initialValues={initialValues}
      validationSchema={validationSchema}
      onSubmit={onSubmit}>
   <form></form>
</Formik>

2. Form Component
Step 1: Import Form
     import {Formik, Form} from 'formik'

Step 2: Replace html <form> tag by <Form> element and remove onSubmit={this.handleSubmit}
   <Form> </Form>
Because the form component is a small wrapper around the html form element that automatically hooks into Formik's handleSubmit method
      
3. FieldComponent - simplifies the code for form field 
Step 1: Import Field from Formik
    import {Formik, Form, Field} from 'formik'
Step 2: Replace all <input> tag with <Field> element
Step 3: Remove {...formik.getFieldProps('name')} from all fields 

FieldComponent does 3 things, first behind the scenes hook up input to toplevel formik components, second it uses name attribute to match up with formik state, third by default field will render input element which is what our form have 

4. ErrorMessage component
     Previously we check if the field has been visited, check if the error exists and it it does we render that error, for this Formik provides ErrorMessage component 

Step 1: Import ErrorMessage from Formik  
     import {Formik, Form, Field, ErrorMessage} from 'formik'

Step 2: Replace rendering error message code with <ErrorMessage> component 
      Pass in a name prop which is equal to name attribute 
<ErrorMessage name='name' />    
<ErrorMessage name='email' />
<ErrorMessage name='channel' />   

It is possible because ErrorMessage component behind the scencs will take care of rendering the error message for the particular field indicated by name prop only if field is visited and error exists 

When we save and run we cant see any error message, but if u keep cursor in the field and we take the cursor then only error message will display 

20. Field Revisted
1. We want to initialize textarea to enter the comments 

const initialValues = {
    name: '',
    email: '',
    channel: '',
    comments: ''
}

2. Add JSX for textarea, when we use Field component it will render only input element not text area, to instruct formik to render this as a textarea, we need to add 'as' prop passing in textarea

<div className='form-control'>
<label htmlFor='comments'>Comments</label>
<Field as='textarea' id='comments' name='comments' />
</div>

'as' prop will accept as its value either input or textarea or select or custom react component, its default value is input so we dont need to specify prop when rendering the input element. Instead of using 'as' prop even we can use 'component' prop but it is deprecated 
   <Field component='textarea' id='comments' name='comments' />

3. Now we want to input element to collect user address, we can do in previous way but now we use render props to display the address 
   We want to initialize address in initialValues

const initialValues = {
    name: '',
    email: '',
    channel: '',
    comments: '',
    address: ''
}
   
4. Now we define address into JSX, here we use render props pattern which use a function as children to the component, so our field component will now have opening and closing tags.
   Next as children we pass in a function which is a arrow function will return JSX (ie) input element to enter the address, but this input element is not hooked into formik so we use props for this arrow function. We use 3 props form, field and meta, field prop is used to take care of name,value,handleChange and handleBlur, meta prop is used to render an error              

<div className='form-control'>
              <label htmlFor='address'>Address</label>
              <Field name='address'>
                {props => {
                     const { field, form, meta } = props 
                  return (
                    <div>
                      <input type='text' id='address' {...field} />
                      {meta.touched && meta.error ? (
                        <div>{meta.error}</div>
                      ) : null}
                    </div>
                  )
                }}
              </Field>
            </div>

21. ErrorMessage revisted
       ErrorMessage components accepts name prop and renders the error message for that particular field, if the field has been visited and an error message exists for that field. 
       When we run and look the browser, and inspect the browser we can see error message we be just text node and not trapped inside any HTML element. 

1. To inform error message component to wrap the error message with an html element we use 'component' prop 
     <ErrorMessage name='name' component='div'/>
Now we can see error message is wrapped around div tag  

2. Now the error message is not in red color, so we create a component that renders its text in red color and then pass that component as compnent prop of error message 
  - Create TextError.js with rfce create functional component  and within JSX render {props.children}
import React from 'react'

function TextError(props) {
    return (
        <div className='error'>
            {props.children}
        </div>
    )
}

export default TextError
   - In YoutubeForm.js, we use TextError instead of div
       <ErrorMessage name='name' component={TextError}/>
Now error message will be display in red color

3. Alternative way is to use Render props pattern for email field 
   We define opening and closing tags for <ErrorMessage> and for children we specify a function, now this function gets the error message as the prop and u can render anything u want to 
<ErrorMessage name='email'>
    {errorMsg => <div className='error'>{errorMsg}</div>}
</ErrorMessage>
Now error message will be display in red color

We should use component prop and specify what should be wrapping component, u can also pass custom component and also can use render props 

22. Nested Objects 
      Previously we create 5 fields and we track form values as key value pairs. Suppose our form want to collect information about the social presence that the user has, so form should ask their facebook and twitter profiles also, so we created and stored as nested objects 

1. We initialize a property called social in initialValues which is an object and that contains facebook and twitter property with empty string 
const initialValues = {
    name: '',
    email: '',
    channel: '',
    comments: '',
    address: '',
    social:{
        facebook:'',
        twitter:''
    }
}

2. Lets add form fields in our JSX 
<div className='form-control'>
              <label htmlFor='facebook'>Facebook profile</label>
              <Field type='text' id='facebook' name='social.facebook' />
            </div>

            <div className='form-control'>
              <label htmlFor='twitter'>Twitter profile</label>
              <Field type='text' id='twitter' name='social.twitter' />
            </div>

23. Arrays
     We need to collect the users phone number,we want to collect their primary and secondary phone number and we want to store it as an array of phone number 

1. Add property phoneNumbers as an array with two empty strings into initialValues object 
const initialValues = {
    name: '',
    email: '',
    channel: '',
    comments: '',
    address: '',
    social: {
        facebook: '',
        twitter: ''
    },
    phoneNumbers:['','']
}

2. Add phoneNumbers into JSX
 <div className='form-control'>
              <label htmlFor='primaryPh'>Primary phone number</label>
              <Field type='text' id='primaryPh' name='phoneNumbers[0]' />
            </div>

            <div className='form-control'>
              <label htmlFor='secondaryPh'>Secondary phone number</label>
              <Field type='text' id='secondaryPh' name='phoneNumbers[1]' />
            </div>

When we run and see the browser

24. FieldArray Component
        - used with common array or list manipulations 
        - Initially we create a property called phoneNumbers and assigned an array with 2 empty strings and in JSX we have field component for each of those indexes, which is fine to collect 2 phone numbers from the user. Typically multiple phone numbers or multiple addresses is handled through dynamic form controls 

1. Import FieldArray from Formik
    import { Formik, Form, Field, ErrorMessage, FieldArray } from 'formik'

2. We need to add new property called phNumbers and value is array with 1 empty string to initialValues object (ie) we asking for just 1 phone number 
const initialValues = {
    name: '',
    email: '',
    channel: '',
    comments: '',
    address: '',
    social: {
        facebook: '',
        twitter: ''
    },
    phoneNumbers:['',''],
    phNumbers:['']
}

3. We need to add JSX
1. First we add <div> tag and label 
    <div className='form-control'>
              <label>List of phone numbers</label>
    </div>

2. Since we list of fields as dynamic, we use FieldArray component with name prop as phNumbers which specify in initialValues object 
 <div className='form-control'>
              <label>List of phone numbers</label>
        <FieldArray name='phNumbers'>
        </FieldArray>
    </div> 

3. To be in control of dynamic form control we need to use renderprops pattern for FieldArray component which is function as children, this function will automatically get some props and using those props we return JSX 
    We add arrow function, this function will automatically get some props and we use in our JSX and called as fieldArrayProps. So this fieldArrayProps will have some array manipulation operations and also form object which contains the entire form. So here we are using only push function to add new phone number,remove function to remove phone number  and 'values' form object to handle entire form 
   - We need push,remove,form from fieldArrayProps, values from form object and phNumbers from values 
    const { push, remove, form } = fieldArrayProps
    const { values } = form
    const { phNumbers } = values
   - Now we need to iterate through phNumbers and render a field component for each value in that array.For that we use map() which takes arrow function as its argument, this function receives each item in the array along with its index and has to return JSX as field component and also need buttons for the user to add or remove the fields dynamically.  Click handlers for this button we use push and remove functions 
   - In order to prevent the user to remove if there is only one phone number for that we checked index>0 then it should display '-' button otherwise it wont display '-' button only 

 {fieldArrayProps => {
                  const { push, remove, form } = fieldArrayProps
                  const { values } = form
                  const { phNumbers } = values
                  // console.log('fieldArrayProps', fieldArrayProps)
                  // console.log('Form errors', form.errors)
                  return (
                    <div>
                      {phNumbers.map((phNumber, index) => (
                        <div key={index}>
                          <Field name={`phNumbers[${index}]`} />
                          {index > 0 && (
                            <button type='button' onClick={() => remove(index)}>
                              -
                            </button>
                          )}
                        </div>
                      ))}
                      <button type='button' onClick={() => push('')}>
                        +
                      </button>
                    </div>
                  )
                }}


25. FastField component 
       - used for performance optimization 
       - FastField is an optimized version of Field component which internally implements shouldComponentUpdate lifecycle method to block on additional rerenders unless there are direct updates to fastfield form control itself. So if any particular field is independent of all other fields in ur form then we can use FastField component 
       - used when ur form has more than 30 fields or if there are fields with very complex validation requirements 

1. Now we try to put console.log('Field Render') inside render props of address field
    {props => {
                    console.log('Field Render')
When we save and look the browser, on page load the statement is logged twice on console. Now we type some text in channel textbox, you can see the statement continue to logged in console, the change in form state is causing all the fields in form to rerender, so uf we type something in channel field it will cause address field to rerender 

2. Import FastField from Formik
     import { Formik, Form, Field, ErrorMessage, FieldArray, FastField } from 'formik'

3. Replace Field with FastField for address form control 
    <FastField name='address'>
    </FastField>

When we save and look to browser, when we type something in channel field we dont see any log statement, but when we type in address field we can see log statement 

26. Field Level Validation
        Previously we saw 2 ways to specify the validation rules for our entire form 
    1. we pass in custom validation function using validate prop
    2. We specify yup object schema using validation schema prop
  Both these props are available on top level formik component. But Formik also specify a validation function at a field level 

1. Now we apply validation rule at field level for comments textarea, so we need to define a validate function  called validateComments that works only for comments field, this function is an arrow function will automatically reveive the value of the comments field, within the function body we declare variable called error, then check if the value is empty and assign the message and return the error 
const validateComments = value => {
    let error 
    if(!value){
        error='Comments is required'
    }
    return error
}

2. So in comment field we can pass in validate prop and assign this validate function 

<Field as='textarea' id='comments' name='comments' validate={validateComments}/>  

3. To display error message we need ErrorMessage component and to display in red color we use TextError component

 <ErrorMessage name='comments' component={TextError} />

When we save and look at browser, so when we didnt give any text in comments it will display error message


27. Manually triggering validation
        We see how to manually trigger both form and field level validation with formik, to trigger validations manually formik provides with 2 helper methods, to access those methods we use render props pattern on entire form itself
       In address field we have a function as children tht automatically receives some props and then return some JSX and for FieldArray phNumbers also we have same pattern function as chidren
      Now we have function as children on top level formik component, this function will return some props which we call as formik and return the entire form 

1. Within <Formik> we create function as children and receives props which we called as formik and return JSX which is entire Form component 

 <Formik
     initialValues={initialValues}
     validationSchema={validationSchema}
     onSubmit={onSubmit}
     >
      {
          formik => {
              return(
                //paste entire <Form> tag here
              )
          }
      }     
 </Formik>

formik props which controls everything that has to do with our form 

2. Now we want manually trigger field level and form level validation. To do it we create 2 button before the submit button
   First button is use to validate comments field since we have written a field level validation and second button to validate the entire form 

<button type='button'>Validate comments</button>
<button type='button'>Validate all</button>

3. formik props 2 helper method called validateField and validateForm, we use those method to validate
   - So in onClick which is equal to arrow function with formik.validateField and pass the field name 'comments'
    <button type='button' onClick={() => formik.validateField('comments')}>Validate comments</button>
   - Next in onClick which is equal to arrow function with formik.validateForm()
 <button type='button' onClick={() => formik.validateForm()}>Validate all</button>

4. Now we want to display the error message when it is touched, for that formik provides 2 helper methods called setTouched and setFieldTouched, so we create 2 more buttons for that 

 <button type='button' onClick={() => formik.setFieldTouched('comments')}>Visit comments</button>
         <button type='button' onClick={() => formik.setTouched({
                  name: true,
                  email: true,
                  channel: true,
                  comments: true
                })}>Visit Fields</button>

When we save and look at browser,first we click on 'Validate Comment' button nothing changes in UI, when we click 'Visit Comments' now we can see the error message. Similarly when we click 'Validate All' nothing changes but when we click 'Visit  Fields' then we can see the error messages 


28. Disabling submit button when validity of form state - Option 1
1.Formik provides 'isValid' which is read only property that is set to true if the errors object is empty 
 <button type='submit' disabled={!formik.isValid}>Submit</button>

2. Add validateOnMount prop to true in <Formik> component, so on page loads as soon as the form mounts on DOM formik will run the validations against each field and populate the error object and if errors object is not empty then isValid is fals e, if isValid is false the form state is invalid so submit button is disabled

<Formik
       initialValues={initialValues}
       validationSchema={validationSchema}
       onSubmit={onSubmit}
       validateOnMount
       >
This is useful for a form with very few fields with simple validation 

29. Disabling submit button when validity of form state - Option 2
    Formik provides with another property called 'dirty' which is a boolean values which indicates if atleast one of formfields value has changed since it was initialized 

1. Comment validateOnMount prop in <Formik>

2. In submit button we add one more condition
<button type='submit' disabled={!(formik.dirty && formik.isValid)}>Submit</button>

Here we say formik to disable the submit button if user has changed any field value and the form in not invalid state 

3. Save the file and go back to browser, submit button is disabled and when we enter some text in all fields then only the button is enabled.
   But there is again drawback, consider we set some initial values for name,email, channel and comments

const initialValues = {
    name: 'sam',
    email: 'sam@gmail.com',
    channel: 'youtube',
    comments: 'good',
    address: '',
    social: {
        facebook: '',
        twitter: ''
    },
    phoneNumbers:['',''],
    phNumbers:['']
}

When u save and run, still the submit button is disabled even though all fields contains data, just because we didnt change form fields value and not allowed to submit the form.
    So this option of using dirty to disable submit button is based on assumption that on page load without the user changing any of form field values, the form state is always invalid. If the user interact with ur form and enter values which will never be exactly the same values as the initial values object then u can use this option 

30. Disabling submit button when form is submitting in background
    Consider we have user registration form when u fill in details and click on submit button and API call is made in the background to register the user. During this time it is important to disable the submit button, if not the user might end up clicking the submit button twice or more number of times so it would be a problem 
    Formik provides with a property called isSubmitting which is a boolean property, formik will set to true if a form submission has been attempted and we check isSubmitting is true and if it is true then disable the submit button 

1. Remove the initial value set in initialValues property

2. In submit button
 <button type='submit' disabled={!formik.isValid || formik.isSubmitting}>Submit</button>

When we save and look the broswer, now fill all values in fields and click submit button, the form data is submitted but submit button is disabled and this in intended behaviour because formik dosent know when API is going to respond, so we manually set isSubmitting to false again 

3. We do in onSubmit which receives another props called onSubmitProps which calls setSubmitting(false) which update isSubmitting to false which enable the submit button 
const onSubmit = (values,onSubmitProps) => {
    console.log('Form data', values)
    onSubmitProps.setSubmitting(false)
}

When we save and look the browser, after fill in values and click submit button, the data is submitted and button is enabled 

31. Load Saved data
       For registration or login form we dont have to load save data however when u deal with forms that are broken into sections with several fields, u want user to save the progress came back at later time and continue 
       Apart from rendering the form we also need to fetch the saved data and fill those values into our form 

1. Define saved data object called savedValues which is similar to same structur e of initial values object 
const savedValues = {
  name: 'Vishwas',
  email: 'v@example.com',
  channel: 'codevolution',
  comments: 'Welcome to Formik',
  address: '221B Baker Street',
  social: {
    facebook: '',
    twitter: ''
  },
  phoneNumbers: ['', ''],
  phNumbers: ['']
}

2. Add a button to load this saved data, so we comment all button except submit button, so onClick of this button we change formik from reading initial values to reading saved values to do it create state variable and update it 

<button type='button'>Load saved data</button>

3. Import useState  
    import React, { useState } from 'react'
  
  -Declare a new state variable with initial value of null inside the function 
   const [formValues, setFormValues] = useState(null)

4. In onClick of button, we set the formValues state variable to savedValues 
<button type='button' onClick={() => setFormValues(savedValues)}>Load saved data</button>

5. We will change the value for the initialValues prop on the formik component  as {formValues || initialValues}

<Formik
        initialValues={formValues || initialValues}
        validationSchema={validationSchema}
        onSubmit={onSubmit}
        //validateOnMount
        >
</Formik>
   
6. Finally we have to add enableReinitialize prop on Formik component because it decides whether ur form can change initialValues after the form has been initialized 

 <Formik
        initialValues={formValues || initialValues}
        validationSchema={validationSchema}
        onSubmit={onSubmit}
        enableReinitialize
        //validateOnMount
        >
</Formik>

When save and look at browser, initially the form is empty because it has initialvalues, but when we click Load Saved data button we can have savedValues in text field 


32. Reset Form data 
Scenario 1:
 - Resetting the form data with reset button 
     <button type="reset">Reset</button>

Scenario 2:
   Resetting the form data after form submission has completed, if you are able to successfully submit ur form, u see the success message and the form would have reset the values to facilitate another submission, to handle this scenario we use submit props in onSubmit method 

const onSubmit = (values,onSubmitProps) => {
    console.log('Form data', values)
    onSubmitProps.setSubmitting(false)
    onSubmitProps.resetForm()
}

When we save and look the browser, first we fill the details in form and then click submit button,the data will be submitted and data was reset 
   So u can reset the data by calling reset button or calling  resetForm() on onSubmit handler 


Reusable Formik Controls
     We build a set of reusable formik controls that can be applied across a variety of forms such as registration, login etc

1. Create Formik-Controls-Demo project 
     >npx create-react-app formik-controls-demo
     >npm install formik
     >npm install yup

2. In App.js, remove <header> under <div> tag
3. In src folder create new folder called components 
4. Create FormikContainer.js with rfce react snippet create a functional component 
5. Import Formik, Form and Yup library
      import {Formik, Form} from 'formik'
      import * as Yup from 'yup'

6. We create initialValues which is empty object, validationSchema and onSubmit which simply logs the form values 
const initialValues = {}
const validationSchema = Yup.object({})
const onSubmit = values => console.log('Form data',values)

7. For JSX, we return Formik component with render props pattern which is function as children and function which automatically receives props called as 'formik' which return a Form component, within Form component we add a submit button. 
  On Formik component we specify 3 props called initialValues, validationSchema and onSubmit 

function FormikContainer() {
    const initialValues = {}
    const validationSchema = Yup.object({})
    const onSubmit = values => console.log('Form data',values)

    return (
       <Formik initialValues={initialValues} validationSchema={validationSchema} onSubmit={onSubmit}>
          {
               formik => (
                  <Form>
                    <button type='submit'>Submit</button>
                  </Form>
              )
          }
       </Formik>
    )
}

export default FormikContainer

7. In App.css, add all styles from previous project

8. Include FormikContainer in App.js and import it
      <FormikContainer/>

9. Create FormikControl.js with rfce react snippet create a functional component 
   This component decide which of the different form fields have to be rendered based on one particular prop called 'control' and rest of props from ...rest,  to decide which component to render we use a simple switch case 

function FormikControl(props) {
    const {control,...rest}=props
    switch(control){
        case 'input':
        case 'textarea':
        case 'select':
        case 'radio':
        case 'checkbox':
        case 'date':
        default:  return null
    }
}

export default FormikControl


Input FormikControl
     We need few props to create input component 
  - control='input' which determine type of formik control we need to render 
  - label='Email' which is label text for form field
  - name='email  which is required by formik for the field and error message component
  - type='email' which it can be text or password

1. Now we want to create error message in red color, so we create another component called TextError with rfce as functional component and for JSX return <div> tag with className='error' rendering {props.children}

import React from 'react'

function TextError (props) {
  return <div className='error'>{props.children}</div>
}

export default TextError

2. Create Input.js with rfce create functional component, we need Field and ErrorMessage from Formik so we import it
   Next this component receives number of props and we destructure label, name and ...rest, finally add in JSX label, Field and ErrorMessage

import React from 'react'
import { Field, ErrorMessage } from 'formik'
import TextError from './TextError'

function Input (props) {
  const { label, name, ...rest } = props
  return (
    <div className='form-control'>
      <label htmlFor={name}>{label}</label>
      <Field id={name} name={name} {...rest} />
      <ErrorMessage component={TextError} name={name} />
    </div>
  )
}

export default Input

3. Add code in FormikControl component, so from props we extract control and rest of props(...rest). In switch if case is input then we return Input component that we created and pass rest of props 
 case 'input':
      return <Input {...rest} />

4. In FormikContainer component we can test the code we written 
  - First we add property in initialValues object 
         const initialValues = {
              email:''
         }
  - Next we add required validation in validationSchema
         const validationSchema = Yup.object({
               email: Yup.string().required('Required')
         })
  - In JSX we can include formik control with props, first we specify what type of control using 'control', next we specify that input type is email, pass label prop as email and name as email
     <FormikControl control='input' type='email' label='Email' name='email'/>

When we save and look browser, we can see email field along with label, when we click in and out we can see the validation, input email and click button the value is submitted


TextArea Formik control
      We need few props to create textarea component 
  - control='textarea' which determine type of formik control we need to render 
  - label='Description' which is label text for form field
  - name='description  which is required by formik for the field and error message component

1. Create TextArea.js with rfce to create functional component, we import Field, ErrorMessage from Formik so we import it
   From the props this component receives we destructure label,name and rest of props as ...rest. Finally we add in JSX label, Field and ErrorMessage 

import React from 'react'
import { Field, ErrorMessage } from 'formik'
import TextError from './TextError'

function TextArea (props) {
  const { label, name, ...rest } = props
  return (
    <div className='form-control'>
      <label htmlFor={name}>{label}</label>
      <Field as='textarea' id={name} name={name} {...rest} />
      <ErrorMessage component={TextError} name={name} />
    </div>
  )
}

export default TextArea

2. Add the code in FormikControl component
case 'textarea':
      return <Textarea {...rest} />

3. We add code in FormikContainer to test the code,
  - First we add property in initialValues object 
         const initialValues = {
              email:'',
              description:''
         }
  - Next we add required validation in validationSchema
         const validationSchema = Yup.object({
               email: Yup.string().required('Required'),
               description: Yup.string().required('Required'),
         })
  - In JSX we can include formik control with props, first we specify what type of control using 'control', next we specify that input type is testarea, pass label prop as description and name as description
     <FormikControl control='textarea' label='Description' name='description' />

When we save and look browser, we can see email and description field 

So first define TextArea component extract necessary props and use them, label for HTML label tag, name for id and name for field component, name prop on ErrorMessage component. Once component is ready we import in FormikControl and return it for appropriate case, use FormikContainer to test it 

Select Formik Control 
    We need few props to create select component 
  - control='select' which determine type of formik control we need to render 
  - label='Select a topic' which is label text for form field
  - name='selectOption  which is required by formik for the field and error message component
  - options=[{key,value}] which is an array of object which contains key value pairs which used to populate the drop down for our select component 

1. Create Select.js with rfce, create functional component, we need Field, ErrorMessage component from Formik so we import it 
   From the props this component receives we destructure label, name, options and rest of props as ...rest. Finally we add them in JSX we add label,Errormessage and Field as well as list of options as children to field component 
   We need to render list of options for which we use options prop with map() which gives access to each option object with which we return option HTML element 

import React from 'react'
import { Field, ErrorMessage } from 'formik'
import TextError from './TextError'

function Select (props) {
  const { label, name, options, ...rest } = props
  return (
    <div className='form-control'>
      <label htmlFor={name}>{label}</label>
      <Field as='select' id={name} name={name} {...rest}>
        {options.map(option => {
          return (
            <option key={option.value} value={option.value}>
              {option.key}
            </option>
          )
        })}
      </Field>
      <ErrorMessage component={TextError} name={name} />
    </div>
  )
}

export default Select

2. Add code in FormikControl component
case 'select':
      return <Select {...rest} />

3. We add code in FormikContainer to test the code,
  - We define a constant options which contain list of options for our drop down 
       const dropdownOptions = [
    { key: 'Select an option', value: '' },
    { key: 'Option 1', value: 'option1' },
    { key: 'Option 2', value: 'option2' },
    { key: 'Option 3', value: 'option3' }
  ]
  - First we add property in initialValues object 
         const initialValues = {
              email:'',
              description:'',
              selectOption: ''
         }
  - Next we add required validation in validationSchema
         const validationSchema = Yup.object({
               email: Yup.string().required('Required'),
               description: Yup.string().required('Required'),
                selectOption: Yup.string().required('Required')
         })
  - In JSX we can include formik control with props, first we specify what type of control using 'control', next we specify that input type is select, pass label prop as Select a Topic and name as selectOption
    <FormikControl control='select' label='Select a topic' name='selectOption' options={dropdownOptions}/>

When we save and look browser, we can see email,description and select field 


Radio FormikControl
    To implement group of radio buttons we need to use render props pattern for the field component 
      We need few props to create radio button component 
  - control='radio' which determine type of formik control we need to render 
  - label='Pick one option' which is label text for form field
  - name='radioOption  which is required by formik for the field and error message component
  - options=[{key,value}] which is an array of object which contains key value pairs which used to render individual radio buttons for the component

1. Create RadioButtons.js with rfce, create functional component, we need Field, ErrorMessage component and import it
   From the props this component receives we destructure label, name, options and rest of props as ...rest. Finally we add them in JSX we add label,Errormessage and Field. Field component uses render props pattern, so within opening and closing brace we add function as children which is arrow function
    In arrow function we destructure 'field' prop, which return JSX (ie) group of radio buttons based on options prop. To iterate over an array in react we use map(), within body for each option we return a combination of input and label 
   Since we cant return multiple elements we use <React.Fragment>, inside we add input element

import React from 'react'
import { Field, ErrorMessage } from 'formik'
import TextError from './TextError'

function RadioButtons (props) {
  const { label, name, options, ...rest } = props
  return (
    <div className='form-control'>
      <label>{label}</label>
      <Field name={name} >
        {({ field }) => {
          return options.map(option => {
            return (
              <React.Fragment key={option.key}>
                <input
                  type='radio'
                  id={option.value}
                  {...field}
                  {...rest}
                  value={option.value}
                  checked={field.value === option.value}
                />
                <label htmlFor={option.value}>{option.key}</label>
              </React.Fragment>
            )
          })
        }}
      </Field>
      <ErrorMessage component={TextError} name={name} />
    </div>
  )
}

export default RadioButtons

2. Add code in FormikControl component
case 'radio':
      return <RadioButtons {...rest} />

3. We add code in FormikContainer to test the code,
  - We define a constant options which contain list of options for our radiobutton 
     const radioOptions = [
    { key: 'Option 1', value: 'rOption1' },
    { key: 'Option 2', value: 'rOption2' },
    { key: 'Option 3', value: 'rOption3' }
  ]
  - First we add property in initialValues object 
         const initialValues = {
              email:'',
              description:'',
              selectOption: '',
              radioOption: ''
         }
  - Next we add required validation in validationSchema
         const validationSchema = Yup.object({
               email: Yup.string().required('Required'),
               description: Yup.string().required('Required'),
                selectOption: Yup.string().required('Required'),
               radioOption: Yup.string().required('Required'),
         })
  - In JSX we can include formik control with props, first we specify what type of control using 'control', next we specify that input type is radio, pass label prop as Radio Topic and name as radioOption
     <FormikControl control='radio' label='Radio topic' name='radioOption' options={radioOptions} />

When we save and look browser, we can see email,description,select,radio field 
    
On react point of view, the code execution starts in FormikContainer, we include FormikControl component specifying radio as control prop, since control is radio in FormikControl it calls RadioButtons component
   It comes to RadioButtons component, here first we need to render label for the overall component which is 'Radio Topic', then we use Render props pattern for Field component, this field should render list of input and label pairs, which contains <input> and <label> tag 
  On <input> we have type='radio', id contains value of each object from radioOptions array (ie) rOption1, rOption2, rOption3, value which also contains value of each object from radioOptions array. We have <label> element which has text is the key in options array. {...field} props take care of name attribute which is radioOption and automatically add to input element as well as the change and blur events on each of radio components 


Checkbox Group FormikControl 
       We need few props to create checkbox component 
  - control='checkbox' which determine type of formik control we need to render 
  - label='Pick options' which is label text for form field
  - name='checkboxOption  which is required by formik for the field and error message component
  - options=[{key,value}] which is an array of object which contains key value pairs which used to render individual checkbox for the component

1. Create CheckboxGroup.js with rfce, create functional component, we need Field, ErrorMessage component and import it
   From the props this component receives we destructure label, name, options and rest of props as ...rest. Finally we add them in JSX we add label,Errormessage and Field. Field component uses render props pattern, so within opening and closing brace we add function as children which is arrow function
    In arrow function we destructure 'field' prop, which return JSX (ie) group of radio buttons based on options prop. To iterate over an array in react we use map(), within body for each option we return a combination of input and label 
   Since we cant return multiple elements we use <React.Fragment>, inside we add input element

import React from 'react'
import { Field, ErrorMessage } from 'formik'
import TextError from './TextError'

function CheckboxGroup (props) {
  const { label, name, options, ...rest } = props
  return (
    <div className='form-control'>
      <label>{label}</label>
      <Field name={name}>
        {({ field }) => {
          return options.map(option => {
            return (
              <React.Fragment key={option.key}>
                <input
                  type='checkbox'
                  id={option.value}
                  {...field}
                  {...rest}
                  value={option.value}
                  checked={field.value.includes(option.value)}
                />
                <label htmlFor={option.value}>{option.key}</label>
              </React.Fragment>
            )
          })
        }}
      </Field>
      <ErrorMessage component={TextError} name={name} />
    </div>
  )
}

export default CheckboxGroup

We just check if the value for the checkbox is present in array of values for this entire field, if it is present checked is set to true 

2. Add code in FormikControl component
 case 'checkbox':
      return <CheckboxGroup {...rest} />

3. We add code in FormikContainer to test the code,
  - We define a constant options which contain list of options for our radiobutton 
      const checkboxOptions = [
    { key: 'Option 1', value: 'cOption1' },
    { key: 'Option 2', value: 'cOption2' },
    { key: 'Option 3', value: 'cOption3' }
  ]
  - First we add property in initialValues object 
         const initialValues = {
              email:'',
              description:'',
              selectOption: '',
              radioOption: '',
              checkboxOption: []
         }
  - Next we add required validation in validationSchema
         const validationSchema = Yup.object({
               email: Yup.string().required('Required'),
               description: Yup.string().required('Required'),
                selectOption: Yup.string().required('Required'),
               radioOption: Yup.string().required('Required'),
               checkboxOption: Yup.array().required('Required')
         })
  - In JSX we can include formik control with props, first we specify what type of control using 'control', next we specify that input type is checkbox, pass label prop as Checkbox Topic and name as checkboxOption
     <FormikControl control='checkbox' label='Checkbox topics' name='checkboxOption' options={checkboxOptions} />

When we save and look browser, we can see email,description,select,radio,checkbox field 

DatePicker FormikControl
1. Install react-datepicker
     >npm install react-datepicker

We add Field component and to the Field component we pass in name prop and within opening and closing tag we add function as props which is render props pattern. We also need to destructure form in addition to field, from form prop we further destructure to a method called setFieldValue which allows to programmatically set a fields value in the form state
   From field prop we destructure value property which gives value of datepicker at given time. Now render prop pattern return JSX which is DateView component from library. On this component we specify id which is name prop, spread the field props (ie) {...field}, spread rest of props (ie) {...rest}, next we give selected prop which contains value of the prop and onChange we assign an arrow function which receives the changed value as its argument which we can then pass on to setFieldValue method, setFieldValue() accepts 2 arguments, the first one is name of field which is name prop and second argument is the value to set 

Login Form
   Create login forms with reusable formik controls 

1. Create LoginForm.js with rfce create functional component with email and password

Registration Form

1. const validationSchema = Yup.object({
    email: Yup.string()
      .email('Invalid email format')
      .required('Required'),
    password: Yup.string().required('Required'),
    confirmPassword: Yup.string()
      .oneOf([Yup.ref('password'), ''], 'Passwords must match')
      .required('Required'),
    modeOfContact: Yup.string().required('Required'),
    phone: Yup.string().when('modeOfContact', {
      is: 'telephonemoc',
      then: Yup.string().required('Required')
    })
  })


React Hooks

What are Hooks?
   - Hooks are a new feature addition in React version 16.8 which allow you to use React features without having to write a class 
    For example, react component state, previously we can use state only within class components, with hooks it is now possible to use State and other react features without writing a class 
   - Hooks dont work inside the classes, they let use react without classes

Why Hooks?
Reason 1:
   - It is more related to Javascript than React itself
   - To work with classes, u have to understand how 'this' keyword works in Javascript which is very different from how it works in most other languages 
   - Remember to bind event handlers in class components
With hooks you are not working with classes anymore you will not have to face these problems

Reason 2
   - There is no particular way to reuse stateful component logic between components
   - HOC and render props pattern do address this problem but u have to restructure ur components which results to awkward looking code. You endup wrapping ur components with several other components to share the functionality 
   - This makes the code harder to follow, so there is a need to share stateful logic in a better way. Hooks help us in this aspect by allowing us to reuse stateful logic without changing ur component hierarchy 

Reason 3
   - To do how code is placed in a component and fact that complex components become hard to understand, when u had to create components for complex scenarios such as data fetching and subscribing to events 
   - Related code is not organized in one place but scattered across different lifecycle methods 
    For example, data fetching is usually done in componentDidMount and also in componentDidUpdate, event listeners is also set them in componentDidMount and unsubscribe in componentWillUnmount 
   Related code (ie) data fetching in split between componentDidMount and componentDidUpdate, code for event listeners is in different methods. Completely unrelated code on other hand that is data fetching and event listeners endup in same code block that is both of them end up in componentDidMount 
    Because of stateful logic in many cases its not possible to break this components into smaller ones, it would be so much better if all the related code was together. This is another problem ur hooks solve rather than forcing a split based on lifecycle methods, hooks let you split one component into smaller functions based on what pieces are related 

Notes:
1. If u want to use hooks, we have to use react version 16.8 or higher
2. Completely opt-in, u dont have to learn or use hooks if u dont want to
3. Hooks dont contain any breaking changes and the release is 100% backwards compatible 
4. Classes wont be removed from react, u can continue to use classes 
5. You cant use hooks in class component, but ur app can definitely mix classes and functional components with hooks
6. Hooks dont replace ur existing knowledge of React concepts 
7. Instead, Hooks provide a more direct API to the React concepts you already know 


useState Hooks
    Create Functional component and then ran into a situation where u needed to add state,then we need to convert the component into class component because state could be used only in class components,but now we useState within functional component 

Create state with class components
1. Create ClassCounter.js with rce, create a class component and remove export from class 
2. Create state variable called count and initialize to 0
3. Create incrementCount() which increment count value by 1
4. In JSX, create a button and click on that button call incrementCount method  

import React, { Component } from 'react'

class ClassCounter extends Component {
  constructor(props) {
    super(props)

    this.state = {
       count: 0
    }
  }

  incrementCount = () => {
    this.setState({
      count: this.state.count + 1
    })
  }

  render() {
    return (
      <div>
        <button onClick={this.incrementCount}>Count {this.state.count}</button>
      </div>
    )
  }
}

export default ClassCounter

5. Include ClassCounter inside App.js and import it
       <ClassCounter/>
When we save and click the button, it increment the value 

Functional Component with state hook
1. Create HookCounter.js with rfce, create functional component  
2. In JSX, create a button which have onClick handler 
3. useState is a hook that add react state to functional component and it is function so we simply call them, it accepts an argument which is an initial value of state property and returns the current value of state property which we called as 'count' and a method that is capable of updating the state property which is setCount 
   const [count,setCount]=useState(0)
This concept is called Array destructuring which is a concept in ES6
   Here state variable count is initialized to zero and method setCount() capable of changing the count variable, we can use this count variable in JSX and onClick we call setCount() by passing new count value which is count+1

import React, {useState} from 'react'

function HookCounter() {

  const [count, setCount] = useState(0)

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count {count}</button>
    </div>
  )
}

export default HookCounter


4. Include HookCounter in App.js and import it
      <HookCounter/>
When we save and click the button, it increment the value 

Rules of Hooks
1. Only call Hooks at the top level - dont call Hooks inside loops, conditions or nested functions

2. Only call Hooks from React functions - call them from within React functional components and not just any regular Javascript function

useState with previous state
    We see how to set state based on the previous state value , we are going to implement a counter but this counter will have buttons to increment, decrement and reset the count value 

1. Create HookCounterTwo.js with rfce create functional component 

2. We use useState hook to create state variable and corresponding setter function 
     const initialValue=0
     const [count,setCount]=useState(initialCount)

3. We add JSX to print count and 3 buttons to increment, decrement and reset count value 
   For reset button, onClick will be arrow function and call setCount() passing initialCount as argument, which will set count value back to 0
   For increment button, onClick call setCount() and the argument is count+1, similarly for decrement button onClick call setCount() and the argument is count-1

4. Include HookCounterTwo in App.js and import it
        <HookCounterTwo />
When we save and look the browser, all the buttons would be working fine

import React, { useState } from 'react'

function HookCounterTwo() {
	const initialCount = 0
	const [count, setCount] = useState(initialCount)
	
	return (
		<>
			Count: {count}
		<button onClick={() => setCount(initialCount)}>Reset</button>
		<button onClick={() => setCount(count + 1)}>Increment</button>
	        <button onClick={() => setCount(count - 1)}>Decrement</button>
		</>
	)
}

export default HookCounterTwo

When we save and look at browser, all button will work fine

5. Now we create another button 
<button onClick={incrementFive}>Increment 5</button>

6. Create incrementFive() method on click of button,which is an arrow function and within the body, incrementing it by value of 5 and simply looping it 5 times and incrementing by 1 everytime 

        const incrementFive = () => {
		for (let i = 0; i < 5; i++) {
			setCount(count + 1)
		}
	}

When we save and look the browser, when u click 'Increment 5'  button, the count is still increment by 1, the setCount() is reading a state value of the count state variable
   To overcome this, instead of passing in value of new state variable we pass in a function that has access to old state value, so setCount is going to accept a function that has access to the old count so previous count is going to be the argument and within function body is 'previous count + 1'
       const incrementFive = () => {
		for (let i = 0; i < 5; i++) {
			setCount(prevCount => prevCount + 1)
		}
	}
When we save and look the browser, 'Increment 5' button will be increment by 5.
   So if u update state value based on the previous state value always pass in a function that will set new state value 

7. Now we do changes for Increment and Decrement button also 

function HookCounterTwo() {
	const initialCount = 0
	const [count, setCount] = useState(initialCount)
	const incrementFive = () => {
		for (let i = 0; i < 5; i++) {
			setCount(prevCount => prevCount + 1)
		}
	}
	return (
		<>
			Count: {count}
<button onClick={() => setCount(initialCount)}>Reset</button>
<button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>
<button onClick={() => setCount(prevCount => prevCount - 1)}>Decrement</button>
<button onClick={incrementFive}>Increment 5</button>
		</>
	)
}

export default HookCounterTwo

8. We have equivalent class component which uses previous state
class ClassCounterTwo extends Component {
  constructor(props) {
    super(props)

    this.state = {
       count: 0
    }
  }

  incrementCount = () => {
    this.setState(prevState => {
      return {
        count: prevState.count + 1
      }
    })
  }

  render() {
    return (
      <div>
        <button onClick={this.incrementCount}>Count {this.state.count}</button>
      </div>
    )
  }
}

export default ClassCounterTwo


useState with Object
     - We use object as state variable with the useState hook

1. Create HookCounterThree.js with rfce create a functional component 

import React from 'react'

function HookCounterThree() {
    return (
        <div>
            
        </div>
    )
}

export default HookCounterThree


2. Import useState from React 
import React, { useState } from 'react'

3. Within the component, create state variable called name and setter function called setName to update corresponding state variable which is equal to useState and pass default value as an object which contain firstName and lastName, initialize to empty string 
const [name, setName] = useState({ firstName: '', lastName: '' })

4. Define the render function, basically contain 2 input fields one for firstName and another for lastName 
 <div>
            <form>
                <input type="text"/>
                <input type="text"/>
                <h2>Your first name is - {name.firstName}</h2>
			    <h2>Your last name is - {name.lastName}</h2>
            </form>
        </div>

5. Lets handle the value attribute and onChange event on two input fields (ie) on change whenever the user starts typing in something we want to set the firstname property, so we call setName which is setter function for name state variable  and we set firstName equal to e.target.value 

 <input type="text" value={name.firstName} onChange={e => setName({firstName: e.target.value })}/>
			    <input type="text" value={name.lastName} onChange={e => setName({lastName: e.target.value })}/>

So whenever first input value changes we update the firstName property and second field value changes we update the lastName property

6. Include HookCounterThree in App.js and import it
      <HookCounterThree/>
When we save and look at browser, when we type in first input field it will update firstname and we type in second input field it update lastName, but firstName becomes empty. Because useState does not automatically merge and update the object, setState in class component will merge the state but setter function in useState will not merge the state 

7. In order to handle manual merger, we can use spread operator for name, so in onChange arrow function first we spread the name and then set the appropriate property 

  <input type="text" value={name.firstName} onChange={e => setName({...name,firstName: e.target.value })}/>
			    <input type="text" value={name.lastName} onChange={e => setName({...name,lastName: e.target.value })}/>

So we copy every property in name object and then just override the firstName field with a different value 


useState with array
    - We use state hook when state variable is an array

1. Create HookCounterFour.js with rfce create functional component  


function HookCounterFour() {
    return (
        <div>
            
        </div>
    )
}

export default HookCounterFour

2. We declare state variable using useState hook so import it
import React, { useState } from 'react'

3. We destructure items, setItems from the state and useState with an array 
const [items, setItems] = useState([])

4. Next render the items in JSX, we use items.map() and get each item and render the list item, so key is item.id and render item.value 
<ul>
				{items.map(item => (
					<li key={item.id}>{item.value}</li>
				))}
			</ul>

5. Since we dont have any items, we create a button to push the element into array 
<button onClick={addItem}>Add a number</button>

6. In on click we are going to call addItem() which is arrow function and within the function we call setItems() function, now we need to pass the value to set for items array. 
   We know setter function dosent merge and update an object, but in case of array the setter function dosent automatically append the item to the end of list, we need to handle that manually using spread operator.
   So arguments to setItems will be an array and first we spread the items array and then we push a new object, for the new object id is going to be items.length and value is going to be random number between 1 and 10 

const addItem = () => {
		setItems([
			...items,
			{
				id: items.length,
				value: Math.floor(Math.random() * 10) + 1
			}
		])
	}

So whenever addItem() is called, we make a copy of all items in the array using spread operator, to that list of copied items we simply append another object. In that way we are not overwriting the original array, on first iteration items is an empty array so id will be 0 which is items.length and value will be random number between 1 and 10, on next iteration we would have one item in the items array, so we make a copy of that and to that we append a new object. The id this time will be items.length which is equal to 1 and value is random number and same logic continues for subsequent button click 

7. Include HookCounterFour in App.js and import it
      <HookCounterFour/>

When we save and look in browser, when we click on button u can see that new items are added to the state variable 

Summary 
  - useState hook lets you add state to functional component 
  - In classes, the state is always an object. With useState hook, the state dosent have to be an object, it can be an array or number or boolean or string etc 
  - useState hook returns an array with 2 elements, the first element is current value of state and second element is state setter function, we call setter function will new value to set the state will in turn cause the component to rerender 
  - In case new state value depends on previous state value, u can pass function to a setter function, the setter function will receive the previous state as its argument 
  - When dealing with objects or array, always make sure to spread your state variable and then call the setter function to get the expected behaviour 


useEffect Hook
    In class components we have side effects like updating DOM, fetching data from API endpoint and setting up subscriptions or timers, since the render method would be too early to perform side-effects we have to make use of lifecycle methods 
    For example, consider updating the document title to the current counter value, on initial render we want to set the document title to click 0 times so this code goes in componentDidMount() which is executed only once in component lifecycle. We have a button to increment the count state value but when count value increments we also need to update the document title again for that we add same code in componentDidUpdate() lifecycle method and it is called anytime the component updates 
      Consider we have timer, on componentDidMount() we set up a timer to log to console 'hello' for every 5sec, we can clear the timer when the component is being removed from DOM and we do in componentWillUnmount lifecycle method 

Combine two side-effects

componentDidMount(){
        document.title=`You clicked ${this.state.count} times`;
        this.interval=setInterval(this.tick,1000);
     }
     componentDidUpdate(){
        document.title=`You clicked ${this.state.count} times`;
     }
     componentWillUnmount(){
         clearInterval(this.interval)
     }

To update the document title we are writing the same code twice in componentDidMount and componentDidUpdate. Next the code related to the timer setInterval and clearInterval which  are related are put into different lifecycle methods, the code to update the dom and set an interval which are unrelated are put together 
    It would be nice to not repeat code and at the same time group together only the related code, that is were useEffect hook will comes into picture

useEffect
   - The Effect hook lets you perform side effects in functional components
   - It is a close replacement for componentDidMount, componentDidUpdate and componentWillUnmount 

useEffect after render
    - used for causing sideeffects in functional components 
    
1. Create ClassCounterOne.js with rce and create class component 
   In constructor we initialize count to 0, in componentDidMount we use initial value of count and set the document title to count value. So in render() we have button and click on that button we increment the count value by 1. In componentDidUpdate we set the document title again to the updated count value 

import React, { Component } from 'react'

class ClassCounterOne extends Component {
	constructor(props) {
		super(props)
		this.state = {
			count: 0
		}
	}

	componentDidMount() {
		document.title = `Clicked ${this.state.count} times`
	}

	componentDidUpdate(prevProps, prevState) {
			document.title = `Clicked ${this.state.count} times`
		}
	}

	render() {
		return (
			<div>
				<button onClick={() => this.setState({ count: this.state.count + 1 })}>
					Click {this.state.count} times
				</button>
			</div>
		)
	}
}

export default ClassCounterOne

2. Include ClassCounterOne in App.js and import it
      <ClassCounterOne/>
When we save and see that initially the document title is clicked 0 times and when click on button, the current value increments by 1 and updates the title as well 
      
3. Now we replace componentDidMount and componentDidUpdate with useEffect hook 
   Create HookCounterOne.js with rfce,create functional component 

function HookCounterOne() {
    return (
        <div>
            
        </div>
    )
}

export default HookCounterOne

4. We import useState to implement the counter 
import React, { useState} from 'react'

5. Create state variable and corresponding setter function which equal to useState with initial value to 0
     const [count, setCount] = useState(0)

6. In JSX, add a button with click handler to increment the count 

<button onClick={() => setCount(count + 1)}>Click {count} times</button>

so innerHtml displays the count variable and in click handler call setCount method passing count+1

7. Include HookCounterOne in App.js and import it
      <HookCounterOne/>
When we save and run, it will display the button, but we want to change the document title on button click of this functional component 

8. Import useEffect from react
     import React, { useState, useEffect } from 'react'

9. useEffect is also function, we pass parameter which is a function which gets executed after every render of the component, so we pass arrow function which updates the document title 

useEffect(() => {
     document.title=`You clicked ${count} times`
})

When we save and look in browser,initially the document title reads you clicked 0 times and when we click on button the count value increments and the document title is updated. We are causing sideeffects from functional component using useEffect hooks 
   When we specify useEffect we basically requesting react to execute the function that is passed as an argument every time the component renders. useEffect is placed inside the component by doing this we can easily access the components state and props without having to write any additional code 

function HookCounterOne() {
    const [count, setCount] = useState(0)

    useEffect(() => {
        document.title=`You clicked ${count} times`
    })

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>Click {count} times</button>
        </div>
    )
}

export default HookCounterOne


Conditionally run effects
     We saw useEffect hook is called after every single render, in some cases applying the effect after every render might create a performance problem so we need a way to conditionally run an effect from functional component 

1. We use ClassCounterOne.js which is a class component with state variable count initialized to 0, in render function we have a button and onclick of that button we increment the count value by 1, when value increment the state changes which causes the component to rerender and componentDidUpdate will execute setting the document title to updated counter value
   We add text input to this class component which will accept name from the user. Create state variable called name, initialized to empty string name 
       constructor(props) {
		super(props)
		this.state = {
			count: 0,
			name: ''
		}
	}

In JSX, add input element, to capture the input element value we add onChange handler and update the state variable when the text changes.
  <input type="text" value={this.state.name} onChange={e => this.setState({ name: e.target.value })} />

    We want to compare the count value before and after the update and if count value changed then conditionally update the title, to do so we include parameters for componentDidUpdate so within the body we check if previous state count is different from currebt state count then only update the document title 

componentDidUpdate(prevProps, prevState) {
		if (prevState.count !== this.state.count) {
			console.log('Updating document title')
			document.title = `Clicked ${this.state.count} times`
		}
	}
      
When we save and look at browser, when we click on button the title is updated and see the log statement, when we start typing in a name the document title is not updated so we are conditionally updating the title only when appropriate variable changes (ie) only count value changes 

2. Now we implement the same in functional component with useEffect hooks
   In HookCounterOne.js create new state variable for name input element and setName method 
    const [name, setName] = useState('')

3. Next we add input element and onChange we call setName method passing target value 

<input type="text" value={name} onChange={e => setName(e.target.value)} />

4. In order to run conditionally useEffect only when the count value changes, in class component we use check to compare previous state with the current state and only update  if there is a difference 
     For executing an effect we pass in a second parameter which is an array and within this array we need to specify either props or state to change the effect. For our example we need the effect to be executed only when the count value chanhes so within the array we specify count

useEffect(() => {
		console.log('useEffect - Updating document title ')
		document.title = `You clicked ${count} times`
	}, [count])

When we save and look at browser, when we click on button the document title changes and when we type in textbox the effect is not run 

To conditionally run an effect specify the second parameter to useEffect which is an array of values that the effect depends on 

Run effects only once
1. In class component ClassMouse.js, we have a constructor which contains variables to store x and y coordinate position of mouse pointers 
   In componentDidMount we add an eventlistener and listen to the mouse move event and log mouse position in the state variables, we then render that position in UI 

import React, { Component } from 'react'

class ClassMouse extends Component {
	constructor(props) {
		super(props)

		this.state = {
			x: 0,
			y: 0
		}
	}

	logMousePosition = e => {
		this.setState({ x: e.clientX, y: e.clientY })
	}

	componentDidMount() {
		window.addEventListener('mousemove', this.logMousePosition)
	}

	render() {
		return (
			<div>
				X - {this.state.x} Y - {this.state.y}
			</div>
		)
	}
}

export default ClassMouse

When we save and look at browser,when we move mouse around we can see the coordinates changing
   We setup event listener only once and that is in componentDidMount

2. We implement same in useEffect and functional component, Create HookMouse.js with rfce, create functional component 
function HookMouse() {
    return (
        <div>
            
        </div>
    )
}

export default HookMouse

3. Import useState and useEffect from React
import React, { useState, useEffect } from 'react'

4. Create 2 state variables for x and y initialized to 0 
        const [x, setX] = useState(0)
	const [y, setY] = useState(0) 

5. In JSX render these state variables
return (
		<div>
			Hooks - X - {x} Y - {y}
		</div>
	)

6. Now we need to add eventlistener for mouse event and we use useEffect
   useEffect accepts a function as an argument, within the function lets first add log statement and then we add eventlistener 

useEffect(() => {
		console.log('useFffect called')
    window.addEventListener('mousemove', logMousePosition)
})

7. Now define logMousePosition which accepts event as its argument and within the body logs mouse event and set X and Y coordinates 
const logMousePosition = e => {
		console.log('Mouse event')
		setX(e.clientX)
		setY(e.clientY)
	}

8. Include HookMouse in App.js and import it
       <HookMouse />
When we save and look the browser, in the console it display 'useEffect called' from initial render and now when we move mouse around, you can see the effect is called every time the component rerenders 

function HookMouse() {
    const [x, setX] = useState(0)
	const [y, setY] = useState(0) 

    useEffect(() => {
		console.log('useFffect called')
        window.addEventListener('mousemove', logMousePosition)
    })

    const logMousePosition = e => {
		console.log('Mouse event')
		setX(e.clientX)
		setY(e.clientY)
	}

    return (
        <div>
            Hooks - X - {x} Y - {y}
        </div>
    )
}

export default HookMouse


9. We want to be called on initial render only, we specify an empty array as the second parameter to useEffect 
    useEffect(() => {
		console.log('useFffect called')
        window.addEventListener('mousemove', logMousePosition)
    },[])

When we save and look at browser,when we move the mouse around we only have 'mouse event' logs this effect. So we can call componentDidMount with useEffect hook by passing in an empty array as second parameter to useEffect 

10. Now we use componentWillUnmount with useEffect hook, so we create container component for HookMouse which we implemented and in container we simply add a button that will toggle the components visibility 
   - Create MouseContainer.js with rfce create functional component 
function MouseContainer() {
    return (
        <div>
            
        </div>
    )
}

export default MouseContainer

    - Import useState from react 
         import React, { useState } from 'react'
    - Create state variable called display and setter function as setDisplay with initial value to true
         const [display, setDisplay] = useState(true)
    - In JSX, we add a button to toggle display variable between true and false and on click we pass setDisplay by passing not off display 
   <button onClick={() => setDisplay(!display)}>Toggle display</button>
    - If display  variable is set to true we render HookMouse component 
     {display && <HookMouse />}
    - Include HookMouse in App.js and import it
         <MouseContainer/>

When we save and look at browser, we have button and mouse coordinates, so when we move the mouse around we see the coordinates updating and the log statement is printed every time the mouse moves 
   When we click button it will effectively unmount the component from DOM and when we try to move mouse around, we can see warning in console and below the warning 'Mouse Event' is still being logged. Even though the component has been removed, the event listener which belongs to that component is still listening and executing 
    So react is telling u have unmounted the component but when we move mouse around we are asking react to update the state variables for x and y coordinates, the only problem is that component has been unmounted. When u unmount the component make sure u cancel all ur subscriptions and listeners 

11. In case of class component we can call componentWillUnmount() and call window.removeEventListener 
componentWillUnmount() {
		window.removeEventListener('mousemove', this.logMousePosition)
	}

12. In Funtional component HookMouse.js, the function that is  passed to useEffect can return a function which will be executed when the component will unmount, so whatever we return is basically a cleanup function 

useEffect(() => {
		console.log('useFffect called')
    window.addEventListener('mousemove', logMousePosition)

    return () => {
      console.log('Component unmounting code')
      window.removeEventListener('mousemove', logMousePosition)
    }
	}, [])

When we save and look borwser, when we mouse around we see log statement 'Mouse Event' and when we click button we can see the statement 'component  unmounting code' in console, this means eventlistener is removed and when we move mouse around we dont have any warning

useEffect with incorrect dependency 
1. Create IntervalClassCounter.js with rce create class component and remove export from class 
class IntervalClassCounter extends Component {
    render() {
        return (
            <div>
                
            </div>
        )
    }
}

export default IntervalClassCounter

2. Create constructor using rconst and declare state variable 'count' and initialize to 0
  constructor(props) {
        super(props)
    
        this.state = {
             count:0
        }
    }

3. We need to create interval timer in componentDidMount which is going to update the count value by 1, so we create interval timer which runs every second and every second we execute tick()
        componentDidMount() {
		this.interval = setInterval(this.tick, 1000)
	}

4. tick() basically increments the count value by 1 for every seconds 
       tick = () => {
		this.setState({
			count: this.state.count + 1
		})
	}

5. Timers also need to be cleared to avoid memory leaks inside componentWillUnmount
        componentWillUnmount() {
		clearInterval(this.interval)
	}

6. Inside render() we display count value 
        render() {
		 <h1>{this.state.count}</h1>
	}

7. Include IntervalClassCounter in App.js and import it
       <IntervalClassCounter/>

When we save and look into browser, we can see count value is increment every second

8. Now we implement same using useEffect hook in functional component 
   Create IntervalHookCounter.js with rfce create a functional component
function IntervalHookCounter() {
    return (
        <div>
            
        </div>
    )
}

export default IntervalHookCounter

9. Import useState and create state variable called 'count' and initialized to 0
   const [count, setCount] = useState(0)
  We also render this count variable in the browser
  return (
    <div>
      {count}
    </div>
  )

10. Now we want to replicate componentDidMount and tick() in useEffect hook
    tick is an arrow function and within the body we call setCount passing count+1
    const tick = () => {
       setCount(count + 1)
    }

11. Next we use useEffect to replicate componentDidMount, which is arrow function and within the function we set up timer and call tick() every second, this effect will fire after every render and empty array as second parameter 
   Next we call componentWillUnmount for cleanup, so from useEffect we return a function and within the function we clear the interval 

useEffect(() => {
    const interval = setInterval(tick, 1000)
    return () => {
      clearInterval(interval)
    }
	}, [count])

12. Include IntervalHookCounter inside App.js and import it
         <IntervalHookCounter/>
When we save and look browser, we can see class counter is working and hook counter is  incrementing every second  


Fetching data from API endpoint with useEffect 

1. Install Axios package to fetch data from API 
      >npm install axios

2. Create DataFetching.js with rfce create functional component 
function DataFetching() {
    return (
        <div>
            
        </div>
    )
}

export default DataFetching

3. Import useState,useEffect from React and also axios
    import React, { useState, useEffect } from 'react'
    import axios from 'axios'

4. Next step is to fetch the data, we use JSON placeholder, goto https://jsonplaceholder.typicode.com/posts where we can see JSON data 
   Create state variable posts and initialize to an empty array
   const [posts, setPosts] = useState({})

5. We use useEffect to fetch data from url endpoint, which is an arrow function and within the function, we make get request using axios and return a promise which loads the response and in catch block we logs the error 

useEffect(() => {
		axios
			.get(`https://jsonplaceholder.typicode.com/posts/${id}`)
			.then(res => {
               console.log(res)
                setPosts(res.data)
			})
			.catch(err => {
				console.log(err)
			})
    })

6. Next render list of post in browser, we are going to map over posts and for each post we are going to return ordered list where the key is post.id and display post.title
        <div>
             <ul>
		{posts.map(post => (<li key={post.id}>{post.title}</li>))}
	     </ul>
        </div>

7. Include DataFetching.js in App.js and import it
       <DataFetching />
When we save and look into browser, in console we can see response object

8. Now in console we have an infinite loop of data fetching, we want the data to be fetched only once on componentDidMount  using empty dependency list to useEffect, so second parameter for useEffect is an empty array 
useEffect(() => {
		axios
			.get(`https://jsonplaceholder.typicode.com/posts`)
			.then(res => {
               console.log(res)
               setPosts(res.data)
			})
			.catch(err => {
				console.log(err)
			})
    })

When we save and look in browser, we can see data is fetched  only once and same rendered in UI 

9. We see how to fetch individual post by passing id to get request, we goto Jsonplaceholder site and scroll down under Routes we can see '/posts/1' which returns single post with id=1
  Create an input element to accept post id from user, where we need to set the value and listen to onChange event to assign the value back to input element so we need state variable called id and initialize to 1
    const [id, setId] = useState(1)

Now on input element we assign id to value and onChange we call setId 
  <input type="text" value={id} onChange={e => setId(e.target.value)} />

10. Now we change url endpoint for particular id, 
this get request will return single post so we change variable to post and setPost and initial value is empty object instead of empty array 
    const [post, setPost] = useState({})

11. Now we update the url endpoint and change setPosts to setPost
 useEffect(() => {
		axios
			.get(`https://jsonplaceholder.typicode.com/posts/${id}`)
			.then(res => {
               console.log(res)
               setPost(res.data)
			})
			.catch(err => {
				console.log(err)
			})
    },[])

12. Now comment <ul> which display list of post and render a single post
   <div>{post.title}</div>

When we save and look browser, we can see title of post with id=1, but when we change id=2 still we can see only id 1's title, this is because we specify an empty array as an dependency list but it depends on id 

13. Now we specify id as dependency list 
  useEffect(() => {
		axios
			.get(`https://jsonplaceholder.typicode.com/posts/${id}`)
			.then(res => {
               console.log(res)
               setPost(res.data)
			})
			.catch(err => {
				console.log(err)
			})
    },[id])

When we save and look browser, when we change the id its related title would be displayed 

14. We see how to trigger the effect on button click,so create state variable called idFromButtonClick whose value change only on button click and initialize to 1
   const [idFromButtonClick, setIdFromButtonClick] = useState(1)

15. We add a button and onClick of button we set idFromButtonClick variable to the value present in input field which is 'id' variable which is updated onChange 
   <button type="button" onClick={handleClick}>Fetch Post</button>

16. Now create handleClick which is arrow function where we call setIdFromButtonClick passing in current id value which is text input field value
        const handleClick = () => {
		setIdFromButtonClick(id)
	}

17. Now we make useEffect to know dependent on idFromButtonClick value instead of id from onChange

useEffect(() => {
		axios
			.get(`https://jsonplaceholder.typicode.com/posts/${id}`)
			.then(res => {
               console.log(res)
               setPost(res.data)
			})
			.catch(err => {
				console.log(err)
			})
    },[idFromButtonClick])

When we save and look browser, we can see title of id=1 and when we input id=2 then click button we can see the title


Context API
      Context provides a way to pass data through component tree without having to pass props down manually to every level
   Consider a react application which has lots of components, we have App component which is root component and nested within the app component at different levels are several other components. At first level we have components A,B and C , nested within component B is component D and nested within component C is component E and component F is nested inside component E
    The requirement in our appl is that components A,D and F are supposed to display the logged in username, that information is maintained as property in app component, inorder to display username in nested component we need to pass down username as prop. For A component we can pass directly it as props, for component D however we have to pass down username as prop to component B and that in turn has to pass down prop to component D, for component F we have to pass prop from component C then component E and finally to component F 
     Eventhough component B,C,E dosent need the prop we still have to send the prop through them to pass it to further components. If components are need to nested 5 or 10 levels deep all the components inbetween would  have to forward the prop, this especially a problem in certain type of props such as language preference, authenticated user which are required by many components in ur appl 
   If could directly send data to required component without having to manually drill down the props through every level of component tree, this is where context comes into picture.

1. Now we want to pass username props from App component and read that prop in component F which is present above component C,E using context  
   Create ComponentC with rfce create functional component 
and call ComponentE inside ComponentC
function ComponentC() {
    return (
        <div>
            <ComponentE/>
        </div>
    )
}

export default ComponentC

2. Include ComponentC inside App.js and import it 
       <ComponentC/>

3. Create ComponentE with rfce create functional component and call ComponentF

function ComponentE() {
    return (
        <div>
            <ComponentF/>
        </div>
    )
}

export default ComponentE

4. Create ComponentF with rfce create functional component 

function ComponentF() {
    return (
        <div>
            
        </div>
    )
}

export default ComponentF

5. Now we see how to get data from App component to Componentf using context using 3 steps
  1. create context in App.js
        const UserContext = React.createContext()
  2. We need to provide context with value and the provider must wrap children components for the value to be avialable. So we wrap ComponentC using UserContext.Provider and we need to provide context value (ie) 'Senthil' which is username
       <UserContext.Provider value={'Senthil'}>
		<ComponentC />
       </UserContext.Provider> 
   3. We need to consume context value, so in App.js we export the context and in ComponentF.js we import it
   export const UserContext = React.createContext()

   import { UserContext} from '../App'  

6. In ComponentF JSX, we use render props pattern to get hold of the value passed by the context 
       <UserContext.Consumer>
	{user => {
                return <div>User context value {user}</div>
		}
              }
	</UserContext.Consumer>

When we save and look at browser we can see expected output, the value being passed from the provider is being consumed using render props pattern in required component 

7. In App.js we create another context called ChannelContext 
      export const ChannelContext = React.createContext() 

8. We provide this context with value called 'ABC channel', we can provide multiple context values by adding providers at each level 
   <UserContext.Provider value={'Senthil'}>
        <ChannelContext.Provider value={'ABC channel'}>
					<ComponentC />
				</ChannelContext.Provider>
			</UserContext.Provider>

9. In ComponentF we have UserContext which gives access to user and within function body we need to use again render props pattern to get channel name 

<UserContext.Consumer>
				{user => {
					return (
						<ChannelContext.Consumer>
							{channel => {
                return <div>User context value {user}, channel context value {channel}</div>
							}}
						</ChannelContext.Consumer>
					)
				}}
			</UserContext.Consumer>

When we save and look at browser, we can see both the values from App component to ComponentF. 
   You can see so much of nesting, if there was a better way to consume the context values, this is where useContext hook comes in to picture 

10. useContext makes consumption of context value to simpler,lets consume  the value in ComponentE with 3 steps
   1. Import usecontext from React
       import React, { useContext } from 'react'
   2. Import necessary context (ie) UserContext and ChannelContext
       import { UserContext, ChannelContext } from '../App'
   3. Call useContext function passing in the context as its argument and simply write in JSX
   function ComponentE() {

  const user = useContext(UserContext)
  const channel = useContext(ChannelContext)
  return <div> User is {user} and channel is {channel}</div>
}

When we save and look at browser we can see expected output


useReducer hook
     - It is a hook used for state management 
     - It is an alternative to useState
     - useState is built using useReducer 

Hooks so far have meaning behind their names
    - useState related to state
    - useEffects related to side effects
    - useContext related to context API
    - useReducer related to reducers

What is Reducers?
    In Javascript, we have some built-in functions related to array like foreach,map and reduce. reduce() method executes a reducer function that we provide on each element of the array and resulting to single output value 

reduce					useReducer
1. reduce in JS			1. useReducer in react
2. array.reduce(reducer,	2. useReducer(reducer,initial
           initialValue)                              value)
3. singlevalue=reducer(         3. newState=reducer
    accumulator,itemVal)              (currentstate,action)
4. reduce method returns        4. useReducer returns pair of 
      single value                 value-[newstate,dispatch]
                                   dispatch method used to    
                                   specify action

useReducer example
1. Create CounterOne.js with rfce create functional component. 
   In JSX, we create 3 buttons to increment,decrement and reset count value 
        <div>
            <button>Increment</button>
	    <button>Decrement</button>
	    <button>Reset</button>
        </div>

2. We need count variable to display in JSX, this is where we use useReducer 
   1. Import useReducer 
        import React, { useReducer } from 'react'
   2. useReducer() is also function which is called inside functional component, which accepts 2 arguments, first one is reducer function and initialState, create initialState and initialize to 0
      const initialState = 0
   3. We define reducer function which is a arrow function which accepts 2 values (ie) currentState and action, it returns one value which is newState 
   We can think action as an instruction to reducer function, based on what the action specifies the reducer function performs the necessary state transition, in our case we have 3 actions increment,decrement and reset, so within reducer function body we add switch statement 

const reducer = (state, action) => {
	switch (action) {
		case 'increment':
			return state + 1
		case 'decrement':
			return state - 1
		case 'reset':
			return initialState
		default:
			return state
	}
}

so based on action value the function will either increment or decrement or reset the counter value 
      4. We need to get hold of value to display in JSX and also we need a way to call reducer function with appropriate action 
   const [count, dispatch] = useReducer(reducer, initialState)

So useReducer returns the current state which we have called as count and with dispatch method, this method allows us to execute the code corresponding to a particular action
    5. In JSX, we add <div> tag that displays the count value
        <div>Count = {count}</div>
    6. To each of button we add click handler which is arrow function where we dispatch an action for 
  <button onClick={() => dispatch('increment')}>Increment</button>
  <button onClick={() => dispatch('decrement')}>Decrement</button>
  <button onClick={() => dispatch('reset')}>Reset</button>

So argument to dispatch method is the action that is specified in reducer function, when you dispatch increment it adds 1 to current count value, if you dispatch decrement it subtracts 1 from current count value 

3. Include CounterOne in App.js and import it
       <CounterOne/>
When we save and look at browser, we can see increment, decrement and reset button

useReducer Example 2
     We are going to use a state object and an action object 

1. We change CounterTwo from CounterOne 

2. We convert our simple numeric state into an object with property firstCounter and initialize to 0
const initialState = {
	firstCounter: 0
}

3. In JSX we need to render this firstCounter property 
       <div>Count = {count.firstCounter}</div>
Here count refers entire state object but we need only firstCounter value 

4. We convert our simple String action into an object as well , the object is going to contain a property called type which is a string
   <button onClick={() => dispatch({type:'increment'})}>Increment</button>
  <button onClick={() => dispatch({type:'decrement'})}>Decrement</button>
  <button onClick={() => dispatch({type:'reset'})}>Reset</button>

5. So in reducer function, the switch expression is going to action.type which refers to entire object and we access the type property
   For increment and decrement actions we need to return the new state object so return an object where firstCounter is state.firstCounter+1

const reducer = (state, action) => {
	switch (action.type) {
		case 'increment':
			return { firstCounter: state.firstCounter + 1 }
		case 'decrement':
			return {firstCounter: state.firstCounter - 1 }
		case 'reset':
			return initialState
		default:
			return state
	}
}

6. Include CounterTwo.js in App.js and import it
       <CounterTwo />
When we save and look the browser, all 3 buttons are work as expected 

7. Consider an scenario where we need to increment or decrement the counter with value=1. Now we want to add  more button that could increment or decrement value by 5.
   When action is an object, now action object has just one property which is action type, we can add second property called value which should be the number to increment or decrement the counter (ie) value:1
   <button onClick={() => dispatch({type:'increment',value:1})}>Increment</button>
            <button onClick={() => dispatch({type:'decrement',value:1})}>Decrement</button>

   Now we will duplicate 2 buttons and set value = 5 
 <button onClick={() => dispatch({type:'increment',value:5})}>Increment 5</button>
            <button onClick={() => dispatch({type:'decrement',value:5})}>Decrement 5</button>

8. In reducer function instead of hard-coded value of 1, we specify action.value 

const reducer = (state, action) => {
	switch (action.type) {
		case 'increment':
			return { firstCounter: state.firstCounter + action.value }
		case 'decrement':
			return {firstCounter: state.firstCounter - action.value }
		case 'reset':
			return initialState
		default:
			return state
	}
}
When we save and look at browser, we can see all button as expected 

9. Suppose we want to maintain two different counters, then it is simple if state is an object. Now we add other property to initialState as secondCounter with initialValue as 10
const initialState = {
    firstCounter: 0,
    secondCounter: 10
}

10. To change secondCounter value, we are going to create two more switch cases for increment2 and decrement2

case 'increment2':
	return {secondCounter: state.secondCounter + action.value }
case 'decrement2':
	return {secondCounter: state.secondCounter - action.value }

Now we have two properties in the state object, we are changing only one at a time, to get the expected output we have to modify the return statements to merge the state properties by using spread operator 

const reducer = (state, action) => {
	switch (action.type) {
		case 'increment':
			return {...state,firstCounter: state.firstCounter + action.value }
		case 'decrement':
            return {...state,firstCounter: state.firstCounter - action.value }
        case 'increment2':
            return {...state,secondCounter: state.secondCounter + action.value }
        case 'decrement2':
            return {...state,secondCounter: state.secondCounter - action.value }
		case 'reset':
			return initialState
		default:
			return state
	}
}

11. Now we add JSX pertaining to second counter 

<div>Secound Counter = {count.secondCounter}</div>

12. We add 2 more buttons to increment this second counter 

<div>
				<button onClick={() => dispatch({ type: 'increment2', value: 1 })}>
					Increment
				</button>
				<button onClick={() => dispatch({ type: 'decrement2', value: 1 })}>
					Decrement
				</button>
			</div>

When we save and look at browser, we can see buttons with expected outputs

Multiple Reducers
    We maintained state object to track two different counters, to update second counter we also had to create additional switch cases in reducer function, but if we need two counters with exact same state transitions so we can use multiple useReducer hooks

1. Create CounterThree.js 
Copy paste the code from CounterOne.js

2. Include CounterThree in App.js and import it 
      <CounterThree />
When we save and look at browser, we can 3 buttons for increment, decrement and reset 

3. The requirement for us to add another counter which also have same state transitions increment, decrement or reset. If this is the scenario we can create additional counters by using multiple reducers. Now we create another useReducer
   const [countTwo, dispatchTwo] = useReducer(reducer, initialState)

4. In JSX, we can duplicate the code 

<div>Second Count = {countTwo}</div>
			<button onClick={() => dispatchTwo('increment')}>Increment</button>
			<button onClick={() => dispatchTwo('decrement')}>Decrement</button>
			<button onClick={() => dispatchTwo('reset')}>Reset</button>

When we save and look at browser, we can see same counter but working independently even they are using same code. When dealing with multiple state variable that have the same state transitions use multiple useReducers making use of same reducer function 

useReducer with useContext
    We have used useReducer for local state management (ie) at component level. But we want to share state between components (ie) with global state. We can do global state by combining useReducer along with useContext 
    Consider we have an appl with lots of components, we have App.js which is root component and nested inside App.js we have component A,B,C. Each of this component maintain their own counter, so in each of 3 components we make use of useReducer hook and implement the counter 
    In different appl we have slightly different requirement , 3 component A,B,C all need to implement a counter, but this time we need to share the counter value, so instead of implementing 3 different counters we need to implement one counter that is accessible by all the 3 components. So we maintain counter state in App.js but we share the state and the method to change that state down in component tree, passing props to so many levels is definitely bad idea, then we have to use useContext hooks

1. Create ComponentA, ComponentB, ComponentC1, ComponentD, ComponentE1, ComponentF1 with rfce create functional component 

2. In ComponentB we nested ComponentD 

import React from 'react'
import ComponentD from './ComponentD'

function ComponentB() {
    return (
        <div>
            <ComponentD />
        </div>
    )
}

export default ComponentB

3. In ComponentC1 we have nested ComponentE1
import React from 'react'
import ComponentE1 from './ComponentE1'

function ComponentC1() {
    return (
        <div>
            <ComponentE1 />
        </div>
    )
}

export default ComponentC1

4. In ComponentE1 we have nested ComponentF1
import React from 'react'
import ComponentF1 from './ComponentF1'

function ComponentE1() {
    return (
        <div>
            <ComponentF1 />
        </div>
    )
}

export default ComponentE1

5. Include ComponentA, ComponentB, ComponentC1 in App.js and import it 
       <ComponentA />
      <ComponentB />
      <ComponentC1 />

6. We need to maintain count state in App.js and modify that state in component A,D,F1 using 2 steps
    1. Create counter in App.js using reducer hook
const initialState = 0
const reducer = (state, action) => {
	switch (action) {
		case 'increment':
			return state + 1
		case 'decrement':
			return state - 1
		case 'reset':
			return initialState
		default:
			return state
	}
}
    2. We make use of reducer hook which gives us access to the count state as well as dispatch method
   - import useReducer from react
       import React,{useReducer} from 'react'
   - Within App component we define reducer 
   const [count, dispatch] = useReducer(reducer, initialState)
   - In JSX we just render count value
       Count - {count}
For dispatch method we dont want to dispatch any action from appcomponent, we want to dispatch action from nested components

    2. Provide and consume the counter context in requried component 
     We make use of context to provide the count value and dispatch method and consume the same from the nested component 
    - Create context API using createContext 
export const CountContext = React.createContext()
    - We have context, now we provide this context with value using CountContext.Provider and on provider we specify the value attribute as count and dispatch method  
 <CountContext.Provider value={{ countState: count, countDispatch: dispatch }}>
    <div className='App'>
      Count - {count}
      <ComponentA />
      <ComponentB />
      <ComponentC1 />
     </div>
     </CountContext.Provider>

6. We specify useContext hook to consume the state and dispatch method, so in ComponentA.js
    - Import useContext 
import React,{useContext} from 'react'
    - Call context inside function and import it
 const countContext = useContext(CountContext)
    - In JSX we create 3 buttons
Component A {countContext.countState}
      <button onClick={() => countContext.countDispatch('increment')}>Increment</button>
			<button onClick={() => countContext.countDispatch('decrement')}>Decrement</button>
			<button onClick={() => countContext.countDispatch('reset')}>Reset</button>

7. Repeat the same steps for ComponentD and ComponentF1
import React,{useContext} from 'react'
import { CountContext } from '../App';

function ComponentD() {
    const countContext = useContext(CountContext)
    return (
        <div>
            Component D {countContext.countState}
            <button onClick={() => countContext.countDispatch('increment')}>Increment</button>
			<button onClick={() => countContext.countDispatch('decrement')}>Decrement</button>
			<button onClick={() => countContext.countDispatch('reset')}>Reset</button>
        </div>
    )
}

export default ComponentD

import React,{useContext} from 'react'
import { CountContext } from '../App';

function ComponentF1() {
    const countContext = useContext(CountContext)
    return (
        <div>
            Component F {countContext.countState}
            <button onClick={() => countContext.countDispatch('increment')}>Increment</button>
			<button onClick={() => countContext.countDispatch('decrement')}>Decrement</button>
			<button onClick={() => countContext.countDispatch('reset')}>Reset</button>
        </div>
    )
}

export default ComponentF1

Now we save and look at browser, first we have JSX corresponding to App and then 3 different components and all the button works as expected. Now the count value is shared across different component 

In App component we created counter using reducer hook with initial state and define reducer function which modifies that state. We pass as parameters to useReducer which returns current state value and dispatch function, to provide these values we create a context called CountContext 


Fetching data from API endpoint 
    Since useState and useReducer are used for state management, we first use useState to fetch data from API endpoint
    As soon as component mounts we will make an API call to fetch data, while the data is fetched we will show a loading indicator, when data is fetched successfully we will hide the  loading indicator and display the data. If there was an error while fetching the data we hide the loading indicator and display an error message 

1. Install Axios package 
      >npm install axios

2. Create DataFetching1.js with rfce, create a functional component
function DataFetching1() {
    return (
        <div>
            
        </div>
    )
}

export default DataFetching1

3. We need useState for managing the state and useEffect for sideeffects and axios for making http call so import it 

import React, {useState, useEffect} from 'react'
import axios from 'axios';

4. Define state variable required for this data fetching, in our case we need 3 state variable 
   - loading a flag to indicate the data fetching happening in the background we create loading and setLoading with initial value to true
   const [loading, setLoading] = useState(true)
   - To display error if something went wrong, create error and setError with initial value as empty string
   const [error, setError] = useState('')
   - A variable to hold the post which will be fetching from api endpoint called post and setPost with initial value as empty object
    const [post, setPost] = useState({})

5. Now make an api call and set appropriate state, for sideeffects we use useEffect which accepts arrow function as first parameter and for second parameter we pass empty dependency array to ensure our api is called only once (ie) we want componentDidMount behaviour 
   Within arrow function we make get request, for endpoint we use JSONPlaceholder and use endpoint which returns single post (ie) /posts/1. When get request is made a promise is returned, if the request is successful we make 3 state transitions, we set loading to false, set post to response.data which contains post object, set error message to empty to clear any previous message 
   In catch block we set loading to false, set post object to an empty object to hide any existing post that might be displayed in the browser, set error message if anything goes wrong
 useEffect(() => {
    axios.get(`https://jsonplaceholder.typicode.com/posts/1`)
      .then(response => {
        setLoading(false)
        setPost(response.data)
        setError('')
      })
      .catch(error => {
        setLoading(false)
        setPost({})
        setError('Something went wrong!')
      })
  }, [])

6. In JSX, if component is busy in loading the data we display string 'Loading...' else we display the post title. 
      {loading ? 'Loading' : post.title}
If there is an error, we need to display that using 
       {error ? error : null}

7. Include DataFetching1 in App.js and import it 
      <DataFetching1 />
When we save and look browser, it would display the title of post, when we refresh the string 'Loading...' appears for a fraction of second and then post title is displayed
    When we enter incorrect url in the code, then error message gets displayed.
Here we declared 3 state variable and depending on API returning successful response or error we apply appropriate state transitions 

Data Fetching using useReducer and useEffect 
1. Create DataFetching2.js with rfce create functional component 
function DataFetching2() {
    return (
        <div>
            
        </div>
    )
}

export default DataFetching2

2. Import useReducer, useEffect from react and axios

import React, { useReducer, useEffect } from 'react'
import axios from 'axios'

3. We declare initialState and define reducer function 
const initialState = {
	loading: true,
	error: '',
	post: {}
}

4. Reducer function accepts state and action as its argument and returns the updated state. We have 2 cases (ie) one data is fetched successfully and one there was an error fetching, these 2 cases form a switch case in reducer function 
    So action is success then we set loading to false, post to action.payload and error as empty string. If case is error, then we set loading to false, post as empty object and  error as a string 

const reducer = (state, action) => {
	switch (action.type) {
		case 'FETCH_SUCCESS':
			return {
				loading: false,
				post: action.payload,
				error: ''
			}
		case 'FETCH_ERROR':
			return {
				loading: false,
				post: {},
				error: 'Something went wrong!'
			}
		default:
			return state
	}
}

5. Invoking useReducer,useEffect to fetch the data and set the state, so within component we call useReducer() passing reducer function and initial state which returns pair of value which is current state (ie) state and dispatch method
  const [state, dispatch] = useReducer(reducer, initialState)

6. Now make http call using useEffect method, here we data fetching is successful we dispatch an action as FETCH_SUCCESS and payload as response.data 

useEffect(() => {
		axios
			.get(`https://jsonplaceholder.typicode.com/posts/1`)
			.then(response => {
				dispatch({ type: 'FETCH_SUCCESS', payload: response.data })
			})
			.catch(error => {
				dispatch({ type: 'FETCH_ERROR' })
			})
	}, [])

7. In JSX, we display 

{state.loading ? 'Loading' : state.post.title}
{state.error ? state.error : null}

8. Include DataFetchingTwo in App.js and import it
       <DataFetchingTwo />
When we save and look at browser, we can see the title of post 


useState vs useReducer
     Both of them used for state management, but when to use useState and useReducer

Scenario		useState		useReducer
1. Type of state     number,string or       Object or array
variable             boolean

For example, if we manage count value as state variable we can use useState, but if we are managing person object which contains firstName,lastName then we use useReducer

2. Number of                one or two	        Too many
state transitions

If we are managing one or two state variable use useState, but if we make 5 or 10 setState calls then we use useReducer 

3. Related state            No			Yes
transitions

Previously there were only 3 state variable (ie) loading,post,error. If we want to manage using useState however useReducer is better solution because state transtition are related or tied to specific actions. All state variables are updated together when the data is fetched successfully or when there is an error. By making use of useReducer code is predictable and maintainable, if everything is managed at different places with useState is hard 

4. Business            No business logic	complex logic
logic

If state transitions from old value to new value requires some business logic or even complex data transformation always use useReducer hook so all logic is localized to reducer function 

5. Local vs global            Local		Global
state

If we want to maintain local component state then useState is better 


useCallback hook - used to optimize performance 

1. Create Title component with rfce which renders some text

import React from 'react'

function Title() {
  console.log('Rendering Title')
  return (
    <h2>
      useCallback Hook
    </h2>
  )
}

export default Title

2. Create Count component which displays the current age of person 

import React from 'react'

function Count({ text, count }) {
	console.log(`Rendering ${text}`)
	return <div>{text} - {count}</div>
}

export default Count

3. Create Button component to increment age of person 
     It is button element with onClick we call handleClick and innerText is children prop which referes to increment text in ParentComponent 

import React from 'react'

function Button({ handleClick, children }) {
  console.log('Rendering button - ', children)
  return (
    <button onClick={handleClick}>
      {children}
    </button>
  )
}

export default Button
     
4. Create ParentComponent with rfce create functional component
ParentComponent is a container for other components like Title, Count and Button component
   - We declare state variable age and setAge with initial value 25 using useState 
    const [age, setAge] = useState(25)
   - In JSX we have Count component to which we pass age as a text prop 
     <Count text="Age" count={age} />
and in Count component we render those info 
    - Next we have Button component to increment persons age, we are passing prop called handleClick whose value is function called incrementAge 
     <Button handleClick={incrementAge}>Increment Age</Button>
    - We define incrementAge method
const incrementAge=() => {
     setAge(age+1)
}
    - We create state variable salary and setSalary with initialvalue 50000
     const [salary, setSalary] = useState(50000)
    - In JSX, we use Count component to which we pass salary as a text prop
         <Count text="Salary" count={salary} />
    - Next we have Button component to increment persons salary, we are passing prop called handleClick whose value is function called incrementSalary
      <Button handleClick={incrementSalary}>Increment Salary</Button> 
    - We define incrementSalary method
const incrementSalary=() => {
     setSalary(salary+1000)
}

So parent component will display the title, displays person age and provide a button to increment that age, displays person salary and provide a button to increment that salary 

5. Include ParentComponent in App.js and import it
      <ParentComponent />
When we save and look browser, we can see title, person age with button, person salary with button 

6. To understand the performance we add log statement in Title, Count and Button component, so when we see the console

Rendering Title
Rendering Age
Rendering button -  Increment Age
Rendering Salary
Rendering button -  Increment Salary

But when we click Increment Age button, the age value increments and component is rerendered but in logs you can see every component is rerendered. When we click Increment Salary, again every component is rerendered.
   To improve performance we have to restrict rerenders to only components that need to rerender (ie) when we increment the age only the count component related to age should be rerendered and not Title and Button component for salary should not be rerendered. 
   In order to optimize it we use React.memo() which is higher order component that will prevent functional component  from being rerender if its props or state do not change 

7. In Title, Count, Button component while exporting wrap the components with React.memo()

export default React.memo(Title)
export default React.memo(Count)
export default React.memo(Button)

So now the components will only rerender only if there is a change in its props or state 
   When we save and loom browser, on page load we can see all components are loaded, when we click 'Increment Age' button  we can see button to 'Increment Salary' is still being rerender 

Rendering Age
Rendering button -  Increment Age
Rendering button -  Increment Salary

We first see the Title component, it has no props or state of its own and hence does not rerender when we increment the age or salary, next we have count and button related to age, count accepts age as prop and button accepts increment age as props which is dependent on age so when age increments both these components should rerender, but we can see that increment salary button also rerenders but Count component for salary does not rerender 
    This is because new incrementSalary function is created each time ParentComponent rerenders, since function is a prop React.memo() sees prop has changed and will not prevent the rerender, this can be done using useCallback hook  


What is useCallback hook?
     It is a hook that will return a memoized version of the callback function that only changes if one of the dependencies has changed
    In our example useCallback hook will cache the incrementSalary function and return that if salary is not incremented, if salary does increment (ie) if the dependency has changed only then a new function will be returned 

Why callback?
   - It is useful when passing callbacks (ie) functions like incrementAge and incrementSalary
   - To optimized child components that rely on the reference equality to prevent unnecessary renders. We have 3 child components which is optimized using React.memo() to prevent unnecessary rerenders

8. In ParentComponent, we import from React 
    import React, { useState, useCallback } from 'react'
  - We need to call useCallback which accepts a callback function as its first parameter and array of dependencies as second parameter (ie) age and salary 
        const incrementAge = useCallback(() => {
		setAge(age + 1)
	}, [age])

	const incrementSalary = useCallback(() => {
		setSalary(salary + 1000)
	}, [salary])

Both the cases we created cache function which is then passed as prop to child components 

When we save and look at browser, on page loads it loads all component, when we click 'Increment Age' it logs only count and Button component for age alone and salary button is not rerendered 

useMemo hook
    - Also concerned with performance optimization

1. Create Counter.js with rfce create functional component 
function Counter() {
    return (
        <div>
            
        </div>
    )
}

export default Counter

2. Create two state variable using useState, so first import it
    import React, { useState } from 'react'
  - Within function create state variable called counterOne, setCounterOne with initial value to 0
   const [counterOne, setCounterOne] = useState(0)
  - create another state variable called counterTwo, setCounterTwo with initial value to 0
   const [counterTwo, setCounterTwo] = useState(0)
  - Create incrementOne function which is arrow function by calling setCounterOne() passing in counterOne+1, similarly create another function incrementTwo()
  const incrementOne = () => {
		setCounterOne(counterOne + 1)
	}

	const incrementTwo = () => {
		setCounterTwo(counterTwo + 1)
  }
   - In JSX, we add 2 button to display the respective count values along with click handler to increment the count values 
  <div>
               <button onClick={incrementOne}>Count One - {counterOne}</button>
            </div>
			<div>
                <button onClick={incrementTwo}>Count Two - {counterTwo}</button>
			</div>
    
3. Include Counter in App.js and import it
       <Counter />
When we save and look at browser, we can see 2 button and when we click each button, related count value increments 

4. Now we have new requirement that next to first counter we need to indicate whether the count value is an odd number or an even number 
   Create a function isEven() which is arrow function and within the body we return counterOne modulus 2
     const isEven = () => {
          return counterOne % 2 === 0
     }

5. In JSX we include <span> tag and we check it is even we display as 'Even' otherwise 'Odd'
     <span>{isEven() ? 'Even' : 'Odd'}</span>

When we save and look at browser, Initially CounterOne is even, when we increment CounterOne is odd 

6. Inside isEven(), we declare variable 'i' and add while loop which simply iterates for long time 
   
    const isEven = () => {
          let i = 0
          while (i < 2000000000) i++
          return counterOne % 2 === 0
    }
Loop dosent affect return stmt but it does slow down the rate at which we compute whether counterOne is odd or even 

When we save and look at browser, we have 2 button with initial count as 0 and when we click Count One button we can see there is a second or two to delay before UI updates, so UI is slow in updating this is because in the UI we are rendering whether the number is odd or even and that logic is in isEven() which turns out really slow
   When we click 'Counter Two' button still there is a delay with UI updates because everytime the state updates the component rerenders so isEven function is called again so even when we update counterTwo, the ui update is slow

7. Now we want to tell react not to recalculate certain values when unnecessary expecially the one which takes long time to compute 
   In our example we need to tell react not to calculate whether counterOne is odd or even when we are changing counterTwo values, this is where useMemo hook comes into picture 
   useMemo is a hook that will only recompute the cached value when one of dependencies has changed, this optimization heads to avoid expensive calculations on every render 
   - Import useMemo from react
      import React, { useState, useMemo } from 'react'
   - In useMemo, as first argument we pass in the function whose return value needs to be cached (ie) arrow function which calculates number is odd or even and second parameter we need to specify the dependency (ie) our function depends on value of counterOne so whenever counterOne changes we are telling react to recompute the value and not use cached value 
 const isEven = useMemo(() => {
    let i = 0
    while (i < 2000000000) i++
    return counterOne % 2 === 0
  }, [counterOne])

8. In JSX, we remove the parenthesis for isEven because it is not function call it just stores the value 
     <span>{isEven ? 'Even' : 'Odd'}</span>

When we save and look broswer, when we click 'Counter One' button it takes time to update to even or odd, when we click 'Counter Two' button updates is faster because react uses cached value of isEven function to display counterOne is odd or even   
   useCallback caches the provided function instance itself whereas useMemo invokes the provided function and caches its result 


useRef hook
    It makes it possible to access DOM nodes directly within functional components 
    Consider login form as soon as page loads by default uername input field to be focussed

1. Create FocusInput.js with rfce create functional component

2. In JSX we add input element 

3. Include FocusInput in App.js and import it
      <FocusInput />
When we save and look broswer, we can see input element and we want is focused on page load 

4. We need to implement componentDidMount behavior as we want to focus on the input element only once and that is after the component has mounted
   - Import useEffect from react
      import React, { useEffect } from 'react'
   Within component call useEffect which takes arrow function as first argument and dependency array as second argument and within the function we want to focus input element
    useEffect(() => {
        //focus the input
    },[])
   - For that we use useRef and we import it from react 
    import React, { useRef, useEffect } from 'react'
   - Create ref variable by calling useRef and passing the initial value 
      const inputRef = useRef(null)
   - Once we create ref we need to attach it to input element  using ref attribute 
      <input ref={inputRef} type="text" />
   - Call focus() on input element within arrow function
        inputRef.current.focus()

When we save and look at browser, we can see focus will come to input element on page loads 

useRef Example 2:
1. Create ClassTimer.js with rce create class component and remove export
class ClassTimer extends Component {
    render() {
        return (
            <div>
                
            </div>
        )
    }
}

export default ClassTimer

2. We implement an interval timer that takes every second and display the value in the browser 
   - create instance field or class property which point to interval timer
        interval
   - Create constructor using rconst and create state variable called timer with initial value to 0
       constructor(props) {
    super(props)

    this.state = {
       timer: 0
    }
  }
   - We implement componentDidMount and componentWillMount to set and clear our interval timer
    In componentDidMount, we call interval which is setInterval which accepts 2 argument, first is callback function where we simply increment timer state variable by 1, second argument is 1000ms which is interval for timer 
    componentDidMount() {
        this.interval = setInterval(() => {
              this.setState(prevState => ({timer: prevState.timer + 1}))
        }, 1000)
    }
   
    In componentWillUnmount, we will clear the timer
       componentWillUnmount() {
           clearInterval(this.interval)
       }

3. In JSX, we render the timer 
       Class Timer - {this.state.timer} 

4. Include ClassTimer in App.js and import it
       <ClassTimer />
When we save and look at browser, we can see timer value is displayed in browser 

5. Now we want to clear the button based on button click, in JSX we create button and onClick of button we clear the timer
   <button onClick={() => clearInterval(this.interval)}>Clear Timer</button>

When we save and look browser, we can see timer and when we click button the timer stops 

6. Now we want to replicate the same scenario using functional component
   Create HookTimer.js with rfce create functional component 
function HookTimer() {
    return (
        <div>
            
        </div>
    )
}

export default HookTimer

7. We create state variable to hold the timer value, so import useState from react 
   import React, {useState} from 'react'
  - Create state variable timer and setTimer with initial value 0
   const [timer, setTimer] = useState(0)
  - Next we need to replicate the behavior of componentDidMount and componentWillUnmount for that we have useEffect hook, so import it 
    import React, {useState,useEffect} from 'react'
  - Within component call useEffect, first parameter is arrow function within which we setup timer and after that we return cleanup function which will clear the interval and finally specify the empty dependent array 
    useEffect(() => {
    const interval = setInterval(() => {
      setTimer(prevTimer => prevTimer + 1)
    }, 1000)
    return () => {
      clearInterval(interval)
    }
  }, [])
   - In JSX, we display the timer value 
        HookTimer - {timer} 

8. Include HookTimer.js inside App.js and import it
        <HookTimer />
When we save and look browser, we can see both timers working fine 

9. Now we want to clear the timer based on button click,in JSX we create button and on click we clear the interval
   <button onClick={() => clearInterval(interval)}>Clear Timer</button>

When we save and look browser, we will get some error because interval variable is scoped only within useEffect in that case we use useRef
    useRef can hold a reference to DOM node using ref attribute, it can also used to store any mutuable value (ie) the value will persist through the rerenders while also not causing any additional renders when its value changes 

10. Import useref from react 
     import React,{useState,useEffect,useRef} from 'react'
   - Within component invoke useRef and assign it to a variable 
      const interValRef = useRef()
   - Now we change interval to interValRef.current and while clearing interval we call interValRef.current
    useEffect(() => {
    interValRef.current = setInterval(() => {
      setTimer(timer => timer + 1)
    }, 1000)
    return () => {
      clearInterval(interValRef.current)
    }
  }, [])
  
  - Change in button click handler 
 <button onClick={() => clearInterval(interValRef.current)}>Clear Timer</button>

When we save and look browser, we can see timer and when we click button it clear the timer

useRef is used to create a generic container which can hold a mutuable value similar to instance properties on class component, this generic container does not cause rerenders when the data it stores changes at sametime it also remembers the stored data even after other state variables cause rerender of this component (eg) clearing interval timer from eventhandler


Custom Hook
   - It is a javascript function whose starts with 'use'
   - custom hook can also call other hooks if required
   
Why Custom hook?
   - To share logic between two or more components, it is an alternative to HOC's and render props 


Example 1 - Custom Hook
     We are going to create customhook that basically updates the document title

1. Create DocTitleOne.js with rfce create functional component 
function DocTitleOne() {
    return (
        <div>
            
        </div>
    )
}

export default DocTitleOne

2. We want to track of count value and next after every render we want to update the document title to current count value 
  - Import useState  from react
      import React, {useState} from 'react'
  - Create state variable count and setCount with initial value 0
      const [count, setCount] = useState(0)
  - Next in JSX, we add button to increment this count value and on click we increment value by 1
    <button onClick={() => setCount(count + 1)}>Count - {count}</button>

3. Now we want to update the document title to current count value, so updating the document title is side effect so code goes in useEffect hook where first argument is arrow function where we update the document title and second argument is dependency list. In our case we give one dependency called 'count'
   useEffect(() => {
        document.title = `Count ${count}`
   },[count])

4. Include DocTitleOne.js inside App.js and import it
      <DocTitleOne />
When we save and look browser, on page load count is 0 and document title is set to same, when we click button, the same is updated as document title

5. Now we want to update document title but from a different component  
    Create DocTitleTwo.js and copy the code from DocTitleOne and paste in DocTitleTwo

6. Include DocTitleTwo inside App.js and import it
      <DocTitleOne />
      <DocTitleTwo />
When we save and look browser, we can see 2 button and both button works fine 
    We are repeating the same logic in different components, if we have 10 different component that update the document title we dont to definitely repeat the code, this is where we use custom hook

7. We can create custom hook that extracts the logic of updating the document title and reuse the same custom hook in different components 
   - Inside src create new folder called hooks
   - Create useDocumentTitle.js with rfce create functional component 
    The function name for custom hooks should start with "use", it is conventions and also ur react rely on this word to determine whether rules of hooks apply to the function or not 
   copy useEffect code into useDocumentTitle function and pass count as an argument 

import {useEffect} from 'react'

function useDocumentTitle(count) {
  useEffect(() => {
    document.title = `Count ${count}`
  }, [count])
}

export default useDocumentTitle

8. In DocTitleOne.js and DocTitleTwo.js we can replace useEffect code with call to useDocumentTitle 
    useDocumentTitle(count)

When we save and look at browser, we can see 2 button and works as expected 

Custom Hook Example 2:
   We create useCounter used to reuse logic for simple counter 

1. Create Counter1.js

import React from 'react'
import useCounter from '../hooks/useCounter'

function CounterOne() {
	const [count, increment, decrement, reset] = useCounter(0, 1)

	return (
		<div>
			<h2>Count = {count}</h2>
			<button onClick={increment}>Increment</button>
			<button onClick={decrement}>Decrement</button>
			<button onClick={reset}>Reset</button>
		</div>
	)
}

export default CounterOne

2. Create Counter2.js

import React from 'react'
import useCounter from '../hooks/useCounter'

function CounterTwo() {
	const [count, increment, decrement, reset] = useCounter(10, 10)

	return (
		<div>
			<h2>Count = {count}</h2>
			<button onClick={increment}>Increment</button>
			<button onClick={decrement}>Decrement</button>
			<button onClick={reset}>Reset</button>
		</div>
	)
}

export default CounterTwo

3. useCounter.js

import { useState } from 'react'

function useCounter(initialCount = 0, value) {
	const [count, setCount] = useState(initialCount)

	const increment = () => {
		setCount(prevCount => prevCount + value)
	}

	const decrement = () => {
		setCount(prevCount => prevCount - value)
	}

	const reset = () => {
		setCount(initialCount)
	}
	return [count, increment, decrement, reset]
}

export default useCounter

4. Include Counter1, Counter2 in App.js and import it
      <Counter1/>
      <Counter2/>


React Redux
  
What is redux?
   Redux is a predictable state container for Javascript apps

Redux is for Javascript application
    - Redux is not tied to React 
    - It can be used with any UI library or framework such as React, Angular, Vue or even vanilla Javascript
    - Redux is a library for Javascript applications

Redux is a state container
    - Redux stores the state of your application. Consider we have login form, the state of component is simply an object that holds username, password and submitting flag to indicate submit action happening in the background 
     If we had list of users to display, the state of component would be an object that contains an array of users.
     So state of an appl is the state represented by all the individual components of that app, this includes data and UI logic. If ur appl is medium to large in size, the state of appl could be like isUserLoggedIn, what username, their profilePic url, list of online users, is data currently fetched etc
     - Redux will store and manage the application state 

Redux is predictable
     - Redux is state container and im any JS appl the state of the application can change
     For example in a todo list appl, a todo item can go from being in a state of pending to a state of completed 
     - In Redux, all state transitions are explicit and it is possible to keep track of them (ie) the changes to ur appl state become predictable 

Why Redux?
   - To manage the state of ur application in a predictable way, redux can help you


Why Redux+React?
    In React applications where u have a considerable number of components which share some common state, state management could become troublesome, this is where Redux will help you out 
    With Redux your state is contained outside ur components, if one component wants to update the state it communicates with the state container, the state container updates the state in predictable manner and then sends the value to only those components that are in need of that value 

React-Redux library
    React is UI library and we have redux which is state management library, they both work independently of each other, to directly use redux in ur react appl is bit confusing and also difficult that is the reason we have React-Redux package which is official Redux UI binding library for React 
   React-Redux offers a couple of functions that will help u to connect ur react appl with redux. So if we use react and redux together then we should also use react-redux to bind two libraries

Summary
1. React is a library used to build user interfaces
2. Redux is a library for managing state in a predictable way in JS applications
3. React-Redux is a library that provides bindings to  use React and Redux together in an application

   
React Redux - Getting started
1. Create folder 'redux-demo'

2. Inside the project, run 
     redux-demo>npm init --yes
It will initialize package.json file with default settings 

3. We add redux as a dependency for our project 
     >npm install redux 

4. Create index.js 
      console.log('From index.js')

5. In terminal, run command
      >node index 
We can see log statement in terminal 


Three core concepts of Redux
    We take a scenario of Cake Shop, we have different entities
   Shop - we have shop itself that stores all cakes on a shelf 
   Shopkeeper - At front of store we have shopkeeper 
   Customer - At the store entrance we have customer 

What are different activities that happen in the scenario?

1. Customer - Buy a cake
    Lets assume we are the customer, so one day we go to the shop with intention of buying cakes, now at the shop u take a look and tell the shopkeeper that u want to buy a cake, u let the shopkeeper know that u want to buy a cake u never jump the counter urself take a cake leave some money on table and exit the store, u can do that but shopkeeper is there to follow a process for u to purchase a cake 

2. Shopkeeper - Remove a cake from the shelf
              - Receipt to keep track
       When you make a request shopkeeper will check if the cake is on the shelf, if so he will box it for u, deduct a cake from his inventory and print out a receipt to keep track of purchase, that will let him know why number of cake on the shelf has decreased 

Three core concepts

Cake shop scenario	   Redux		Purpose
1. Shop - keeps all        Store          Holds the state of
cakes on shelf                            ur appl

2. Intention to BUY_CAKE    Action        Describes what
We went to shop                           happened
and told shopkeeper about
our intention to buy cake

3. Shopkeeper -receives       Reducer	  Ties the store and
action from customer                       actions together 
and then removes cake
from shelf which is 
store 

So Redux is based on 3 core concepts
1. A store that holds the state of your application
2. An action that describes the changes in the state of the appl
3. A reducer which actually carries out the state transition depending on the action 

How do core concepts translate to code, we are writing Javascript appl, how do we write code that represents these concepts, this is where 3 principles of redux comes into picture

Redux Three principles
1. The state of ur whole application is stored in an object tree within a single store 
    With Redux we are told to maintain our application state in a single object which would be managed by the reduc store
    In cake shop scenario, we are tracking the number of cakes on the shelf then we would represent the state of our cake shop application as a single object that contains a property indicating the number of cakes 
    {
       numberOfCakes: 10
    }

2. The only way to change the state is to emit an action, an object describing what happened 
   To update the state of ur appl,you need to let redux know about that with an action, you are not allowed to directly update the state object 
   In Cake shop example, we are not allowed to directly take the cake from shelf instead we need to let the shopkeeper know about our action, our action is to buy cake. In code we represent action as a simple object that contains a type property 
     {
        type:BUY_CAKE
     }

3. To specify how the state tree is transformed by actions, you write pure reducers 
    So second principle told us that state can be transformed  by emitting actions but how should the state transform is what the third principle covers and it tells us that we need to write pure reducers to determine how the state changes. Pure reducers are pure function that take the previous state and an action as input and return the next state 
   Reducer - (previousState,action) => newState

   In cake shop example,the reducer is shopkeeper, when u tell him that u want to buy a cake, he will take one off the shelf, reduce his cake count by 1, print the receipt and then handle the cake.
   In our Javacript appl would be a function that accepts the current state and action as parameters, based on what action type is a new state object is returned, in our scenario type is BUY_CAKE so we simply reduce the count by 1 and return that new count 

const reducer =(state,action) => {
     switch(action.type) {
         case BUY_CAKE: return {
           numOfCakes: state.numOfCakes - 1
         }
     }
}

Three principles overview
   Our application is a simple Javascript appl, the state of appl is maintained separately in redux store, our appl is always subscribed to this redux store, however the app cannot directly update the state, if the appl wants to update the state it has to emit or dispatch an action. Once the action has been dispatched the reducer then handles that action and updates the current state. As soon as the state is updated the value is then passed on to the appl because app is subscribed to the store

Actions
    - The only way your appl can interact with the store  
    - Carry some information from ur app to the redux store 
    - Actions are plain javascript objects 
    - Have a 'type' property that indicates the type of action being performed 
    - The 'type' property is typically defined as string constants 

Create action for cake shop application
1. Define string constant that indicates the type of action 
        const BUY_CAKE='BUY_CAKE'
2. We define our action which is an object that has type property 
        {
           type: BUY_CAKE,
           info: 'First redux action'
        }
3. We create action creator which simply creates an action, in terms of code action creator is a function that returns an action 
function buyCake() {
   return {
           type: BUY_CAKE,
           info: 'First redux action'
        }
}

Reducers
    - Specify how app's state changes in response to actions sent to the store, so action just describe what happens but dont describe how the appl state changes, so reducers are incharge of that
    -  In terms of code, reducer is a function that accepts state and action as arguments and returns the next state of the application 
    (previousState,action) => newState

1. We need 2 argument to write reducer function, the state of appl before making any change and the action. 
   As a shopkeeper all we want to keep track of numberOfCakes on shelf, so our state is simple numeric value 

const initialState = {
    numOfCakes: 10
}

We pass initialState as default value for the state parameter in reducer 

2. Now we define reducer function which is an arrow function which takes state and action, for state parameter we provide default value of initial state and within the function body we will return new state of application based on current state and action 
   If action type is BUY_CAKE we are going to return new state of the application as new object where numOfCakes is the current numOfCakes - 1. Your state object may contain more than one property that is why it is always safer to first create copy of state object and then change only the properties that need to using spread operator

const reducer = (state=initialState,action) => {
   switch(action.type) {
      case BUY_CAKE: return {
         ...state,
         numOfCakes: state.numOfCakes - 1
      }
      default: return state
   }
}

So here we are asking reducer to first make a copy of state object and then only update numOfCakes, if there were other properties they would remain unchanged 

Redux Store
    - For entire appl we will always have just one store 

Responsiblities
    - It is responsible for holding the application state

We already have state of appl as initialState, now we have to create store to hold this, here we introduce redux library
 1. If it is react appl, we import redux but here we just develop as nodejs appl for which we use
       const redux=require('redux')
 2. Redux library provide with createStore() to create the store 
       const createStore=redux.createStore
 3. createStore() accepts a parameter which is reducer function 
    const store=createStore(reducer) 

    - It exposes a method called getState() which gives our appl access to the state it holds

    1. To implement this we add log statement
      console.log('Initial State', store.getState())
Since we have not performed any state transitions yet getState should effectively give us the initialState of the application

      - Store also allows application to register listeners through subscribe(listener), which accepts function as parameter which is executed any time the state in redux store  changes

    1. We call subscribe() which accepts a function and we just log the updated state 
const unsubscribe=store.subscribe(()=>console.log('Updated state',store.getState()))

    - It provides a method called dispatch(action) to allow any updates to the application state, which accepts an action as its parameter 
    
    1. We call dispatch() which accepts an action as its parameter and we call action creator which in turn will return the action, to make few more state transitions we will dispatch the same action two times
      store.dispatch(buyCake())
      store.dispatch(buyCake())
      store.dispatch(buyCake())
  
    - We can also unsubscribe to store by calling the function that was returned by subscribe()
   1. We call unsubscribe method 
         unsubscribe()

    - When we save and run in terminal 
         >node index
Initial State { numOfCakes: 10 }
Updated state { numOfCakes: 9 }
Updated state { numOfCakes: 8 }
Updated state { numOfCakes: 7 }

Initially we have 10 cakes, and for each action of buying a cake, 1 cake has been reduced from the store.
   First execution will start at line const store=createStore(reducer) where we create redux store, the createStore() from redux library accepts a parameter it is the reducer function which controls how the state transition happens. Once the store is created we log to the console the state of appl which is 'Initial state', after that we set up a listener to the store so anytime store updates we log the state to the console. When we dispatch the first action, the reducer sees that the action type is BUY_CAKE, then it will match this type with switch cases then simply decrement number of cakes by 1 and returns new state, so now store state is updated the listener is called which logs to the console the updated state etc, at the end we unsubscribe to any changes in the store 


Requirement 2:
    We were discussing about cake shop, we have cakes stored on shelf, we have shopkeeper and a customer, the customer informs shopkeeper that he wants to buy cake, the shopkeeper takes one off the shelf and hand it over to customer. In our business we want to expant range of products, now we want to sell ice creams in shop 
    So we purchase a freezer and store all icecreams in that freezer. When we it comes to shopkeeper we could tell him to manage both cakes and icecreams but to keep things simple we hire another shopkeeper. When a customer comes with an intention to buy a cake, shopkeeper one will handle the request, if customer wants to buy an icecream shopkeeper two will handle the request. So state on shop is number of cakes in shelf along with number of icecreams in freezer. The reason with this approach of having separate shopkeepers is scalability so in future if we want to sell any other product, we can split the job in to separate shopkeepers it is easier to manage 

Multiple Reducers
   Our shops needs to sell both cakes and icecreams and we decided to have 2 shopkeepers. 
   When it comes to code, shopkeeper is nothing but reducers so we need to have 2 reducers in code 

1. On initialState we add another property numOfIceCreams as 20
   const initialState = {
       numOfCakes: 10,
       numOfIceCreams: 20
   }

2. In reducer we add another switch case called BUY_ICECREAM

      case BUY_ICECREAM: return {
        ...state,
        numOfIceCreams: state.numOfIceCreams - 1
       }

3. Now we define action and action creator to buy icecream

const BUY_ICECREAM = 'BUY_ICECREAM'

function buyIceCream () {
  return {
    type: BUY_ICECREAM
  }
}

4. Now dispatch the action to buy icecreams
      store.dispatch(buyIceCream())
      store.dispatch(buyIceCream())

5. Now save and run in terminal as  >node index
Initial State { numOfCakes: 10, numOfIceCreams: 20 }
Updated state { numOfCakes: 9, numOfIceCreams: 20 }
Updated state { numOfCakes: 8, numOfIceCreams: 20 }
Updated state { numOfCakes: 7, numOfIceCreams: 20 }
Updated state { numOfCakes: 7, numOfIceCreams: 19 }
Updated state { numOfCakes: 7, numOfIceCreams: 18 }

When we buy a cake only number of cakes goes down, the number  of icecreams remain same and when we buy icecream only that changes. But if ur products goes up then creating all in single reducer is difficult to manage and keep track of, so we use multiple reducers (ie) split state and reducer 

6. Now we have 2 initial state for cake and icecream 
const initialCakeState = {
  numOfCakes: 10
}

const initialIceCreamState = {
  numOfIceCreams: 20
}

7. We create 2 reducer for cake and icecreams
const cakeReducer = (state = initialCakeState, action) => {
  switch (action.type) {
    case BUY_CAKE: return {
      ...state,
      numOfCakes: state.numOfCakes - 1
    }
    default: return state
  }
}

const iceCreamReducer = (state = initialIceCreamState, action) => {
  switch (action.type) {
    case BUY_ICECREAM: return {
      ...state,
      numOfIceCreams: state.numOfIceCreams - 1
    }
    default: return state
  }
}

8. Now we want combine multiple reducer into single reducer  for that Redux provides a method called combineReducers() which accepts key value pair for this object 

const combineReducers = redux.combineReducers

const rootReducer = combineReducers({
    cake: cakeReducer,
    iceCream: iceCreamReducer
})
const store=createStore(rootReducer) 

When we save and >node index 
Initial State { cake: { numOfCakes: 10 }, iceCream: { numOfIceCreams: 20 } }
Updated state { cake: { numOfCakes: 9 }, iceCream: { numOfIceCreams: 20 } }
Updated state { cake: { numOfCakes: 8 }, iceCream: { numOfIceCreams: 20 } }
Updated state { cake: { numOfCakes: 7 }, iceCream: { numOfIceCreams: 20 } }
Updated state { cake: { numOfCakes: 7 }, iceCream: { numOfIceCreams: 19 } }
Updated state { cake: { numOfCakes: 7 }, iceCream: { numOfIceCreams: 18 } }

In output, cake and icecream here correspond to the key we specified while combined two reducers, when we dispatch an action both the reducers receive that action, the difference is that one of them acts on that action whereas the other just ignores it 

Middleware 
   - It is the suggested way to extend Redux with custom functionality 
   - It provides a 3rd party extension point between dispatching an action, and the moment it reaches the reducer 
   - Use middleware for logging, crash reporting,performing async tasks etc 

1. We use middleware called Redux logger used to log all the information related to redux in ur appl
    >npm install redux-logger

2. We need to create a logger for our appl using createLogger() method

const reduxLogger = require('redux-logger')
const logger = reduxLogger.createLogger() 

3. To include the middleware using applyMiddleware()
     const applyMiddleware = redux.applyMiddleware

4. Then to createStore() we pass in second parameter as applyMiddleware which is logger middleware
const store = createStore(rootReducer, applyMiddleware(logger))

5. We remove log statement in store subscription as we have logger middleware to handle all of that 
      const unsubscribe = store.subscribe(() => { })

When we save and run >node index, we can see all logs 


Async actions in Redux
   We have seen synchronous actions (ie) as soon as an action was dispatched the state was immediately updated. In out example if we dispatch BUY_CAKE action, the numOfCakes was right away decremented by 1
   However we develop appl in async way, for example you will mahe async API calls to fetch data from endpoint and use that data in ur appl

Example
   The appl we build is simply fetches a list of users from API endpoint and store in redux store

State:
   For data fetching we go for 3 properties for the state object, first property is loading flag which indicates whether the data is currently being fetched or not, second property is data itself (ie) list of users which is empty array with no user loaded, third property is an error message our api request might fail for some reason in that case we use error property 

Actions
1. FETCH_USERS_REQUEST - Fetch list of users from api endpoint
2. If data is fetched successfully then we use action FETCH_USERS_SUCCESS
3. FETCH_USERS_FAILURE - Error fetching the data 

Reducers
   If action type is FETCH_USERS_REQUEST we basically set loading to true. If action type is FETCH_USERS_SUCCESS then loading is false and data is list of users fetched from API. If action type is FETCH_USERS_FAILURE then loading is false and error to the error returned by API

1. Create asyncActions.js

2. Create state with 3 properties like loading, users,error 
const initialState = {
  loading: false,
  users: [],
  error: ''
}

3. We create action creators basically function that returns an action

const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST'
const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS'
const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE'

const fetchUsersRequest = () => {
  return {
    type: FETCH_USERS_REQUEST
  }
}

const fetchUsersSuccess = users => {
  return {
    type: FETCH_USERS_SUCCESS,
    payload: users
  }
}

const fetchUsersFailure = error => {
  return {
    type: FETCH_USERS_FAILURE,
    payload: error
  }
}

4. We create reducer function 
const reducer = (state = initialState, action) => {
  console.log(action.type)
  switch (action.type) {
    case FETCH_USERS_REQUEST:
      return {
        ...state,
        loading: true
      }
    case FETCH_USERS_SUCCESS:
      return {
        loading: false,
        users: action.payload,
        error: ''
      }
    case FETCH_USERS_FAILURE:
      return {
        loading: false,
        users: [],
        error: action.payload
      }
  }
}
If request was successful, the payload was array of users and if the request failed the payload is error message 

5. Create redux store

const redux = require('redux')
const createStore = redux.createStore

const store = createStore(reducer)

6. How to make api call in redux ?
    We install 
       1. axios which used to make get request to api endpoint 
       2. redux-thunk which is package from redux ecosystem and is the standard way to define async action creators in ur appl, it is a middleware applying to redux store 
     >npm install axios redux-thunk

7. Apply redux-thunk middleware for redux store 

const applyMiddleware = redux.applyMiddleware
const thunkMiddleware = require('redux-thunk').default
const axios = require('axios')

const store = createStore(reducer, applyMiddleware(thunkMiddleware))

8. Define async action creators 

const fetchUsers = () => {
  return function (dispatch) {
    dispatch(fetchUsersRequest())
    axios
      .get('https://jsonplaceholder.typicode.com/users')
      .then(response => {
        // response.data is the users
        const users = response.data.map(user => user.id)
        dispatch(fetchUsersSuccess(users))
      })
      .catch(error => {
        // error.message is the error message
        dispatch(fetchUsersFailure(error.message))
      })
  }
}

9. We subscribe to store and dispatch async action creators 

store.subscribe(() => { console.log(store.getState()) })
store.dispatch(fetchUsers())

When we save and run >node asyncActions


React Redux
1. Create react-redux-demo project
     >npx create-react-app react-redux-demo

2. >npm install redux react-redux 

3. Create new folder 'components' inside src folder 

4. Create CakeContainer.js with rfce create functional component, in JSX add
   <div>
      <h2>Number of Cakes</h2>
      <button>Buy Cake</button>
   </div>

5. Remove <header> tag inside <div> tag, include CakeContainer.js inside App.js and import it
      <CakeContainer />

6. Create redux folder inside src folder, so everything related to redux will be contained in this folder 
   - Inside redux folder, create cake folder 
   - Create cakeActions.js inside cake folder where we create  action creator
    import { BUY_CAKE } from './cakeTypes'

    export const buyCake = () => {
         return {
           type: BUY_CAKE,
        }
    }
   - Create cakeTypes.js 
      export const BUY_CAKE = 'BUY_CAKE'
   - Inside cake folder, create cakeReducer.js which is a reducer which is function that accepts state and action as parameter and return new state
    Create initialState with numOfCakes as 10

import { BUY_CAKE } from './cakeTypes'

const initialState = {
  numOfCakes: 10
}

const cakeReducer = (state = initialState, action) => {
  switch (action.type) {
    case BUY_CAKE: return {
      ...state,
      numOfCakes: state.numOfCakes - 1
    }

    default: return state
  }
}

export default cakeReducer

7. Create Redux store and provide it to our react appl, inside redux folder we create store.js within this file we create our store for which we use createStore()

import { createStore} from 'redux'
import cakeReducer from './cake/cakeReducer'

const store = createStore(cakeReducer)
  
export default store

8. Now is to provide this store to our react appl, to provide redux store to our react appl the react redux library exports a component called provider 
  - In App.js, import Provider
      import { Provider } from 'react-redux'
  - Wrap <div> tag in return statement with <Provider> component 
    <Provider>
    <div className="App">
        <CakeContainer />
    </div>
    </Provider>
  - How does Provider component knows about our redux store, for that we need to specify as prop, so first import store 
    import store from './redux/store'
  - In provider component we pass prop called store and pass in the store
     <Provider store={store}>
    <div className="App">
        <CakeContainer />
    </div>
    </Provider>

9. Now we see how to dispatch an action from within react component
   In CakeContainer component we want to display the number of cakes which is part of redux state and this is also the component from which we want to dispatch BUY_CAKE action on a button click using 3 steps
  1. Define a new function mapStateToProps which gets redux state as parameter and returns an object which is numOfCakes
   const mapStateToProps = state => {
  return {
    numOfCakes: state.numOfCakes
  }
}
  2. Define mapDispatchToProps function which gets redux dispatch method as parameter and returns as object 
    const mapDispatchToProps = dispatch => {
  return {
    buyCake: () => dispatch(buyCake())
  }
}
  We have mentioned action creator but not imported, so we create index.js inside redux folder and export all action creators 
   export { buyCake } from './cake/cakeActions'
  Then we import in CakeContainer.js as
    import { buyCake } from '../redux'
  3. Connect these 2 functions with our react component using connect HOC from react redux library
   - Import connect 
       import { connect } from 'react-redux'
   - Next while exporting our component we connect two functions 
    export default connect(
  mapStateToProps,
  mapDispatchToProps
)(CakeContainer)

In mapStateToProps function the state from redux store is mapped to our component props, so apart from whatever props cakecontainer receives it will receive additional prop called numOfCakes which reflects the numOfCakes in redux store. In mapDispatchToProps will map our dispatch of action creator to a prop in component, so our component now receives second additional prop called buyCake which basically dispatch BUY_CAKE action 

function CakeContainer (props) {
  return (
    <div>
      <h2>Number of cakes - {props.numOfCakes} </h2>
      <button onClick={props.buyCake}>Buy Cake</button>
    </div>
  )
}

Now we save and look browser, initially cakes are 10 and when we click button it will be decremented 

React Redux + Hooks
   Previously we define action creators, define our reducers function, provide the store and connect our components to the store. In doing so our react components get access to the redux state and able to dispatch action to redux store 
   React hooks gives the functional component the ability to use local component state, execute sideeffects, since in Redux version 7.1 hooks have been added as an alternative to existing connect HOC. So hooks allow to subscribe to redux store and dispatch actions without having to call connect()

useSelector hook  
1. Create HooksCakeContainer.js with rfce create functional component
   In JSX, we need <h2> tag and button to dispatch the buyCake action 

function HooksCakeContainer() {
    return (
        <div>
            <h2>Num of Cakes</h2>
            <button>Buy Cake</button>
        </div>
    )
}

export default HooksCakeContainer

2. useSelector is a hook the react redux library provides which acts as closed equivalent to the mapStateToProps function which hold of any state that is maintained in redux store, instead we use useSelector hook 
   - import useSelector from redux
       import { useSelector} from 'react-redux' 
   - Within component we call useSelector() which accepts a function as its parameter and this function is called as selector function which receives redux state as its argument, which is similar to mapStateToProps and the function can then return a value 
    const numOfCakes = useSelector(state => state.numOfCakes)
So we access number of cakes in redux state and store it in a variable numOfCakes that belongs to our react component
   - Include this variable in JSX
      <h2>Num of Cakes - {numOfCakes}</h2>

3. Include HookCakeContainer in App.js and import it
        <HookCakeContainer />
When we save and look browser, we can able to access state value from redux store but button click is missing

useDispatch Hook
     - used to dispatch an action with react redux 

1. import useDispatch from react redux
      import { useSelector, useDispatch } from 'react-redux'

2. In the component we call useDispatch hook which returns a reference to the dispatch() from redux store and store in variable called dispatch, this variable used to dispatch actions as needed
        const dispatch = useDispatch()
   - For button, add click handler
   <button onClick={() => dispatch(buyCake())}>Buy Cake</button> 

When we save and look browser, we can see both the button works fine 


Action and Reducer for Icecreams 

1. Inside redux folder, create iceCream folder and create files iceCreamTypes.js, iceCreamActions.js, iceCreamReducer.js

iceCreamTypes.js
   export const BUY_ICECREAM = 'BUY_ICECREAM'

iceCreamActions.js
   import { BUY_ICECREAM } from './iceCreamTypes'

export const buyIceCream = () => {
  return {
    type: BUY_ICECREAM
  }
}

iceCreamReducer.js
import { BUY_ICECREAM } from './iceCreamTypes'

const initialState = {
  numOfIceCreams: 20
}

const iceCreamReducer = (state = initialState, action) => {
  switch (action.type) {
    case BUY_ICECREAM: return {
      ...state,
      numOfIceCreams: state.numOfIceCreams - 1
    }

    default: return state
  }
}

export default iceCreamReducer

2. Next we export in index.js so we can import later
    export { buyIceCream } from './iceCream/iceCreamActions'

3. In store.js we have createStore() which accepts only 1 reducer, if we need multiple reducer then we go for combineReducer()
   Inside redux folder, create rootReducer.js and include all reducer

import { combineReducers } from 'redux'
import cakeReducer from './cake/cakeReducer'
import iceCreamReducer from './iceCream/iceCreamReducer'

const rootReducer = combineReducers({
  cake: cakeReducer,
  iceCream: iceCreamReducer
})

export default rootReducer

4. Now call this rootReducer in Store.js
   - Import rootReducer
       import rootReducer from './rootReducer'
   - Now pass that reducer as argument to createStore()
       const store = createStore(rootReducer)

5. Inside component,create new component for icecream as IceCreamContainer.js 
   Copy and paste the code of CakeContainer and do changes 

import React from 'react'
import { connect } from 'react-redux'
import { buyIceCream } from '../redux'

function IceCreamContainer (props) {
  return (
    <div>
      <h2>Number of ice creams - {props.numOfIceCreams} </h2>
      <button onClick={props.buyIceCream}>Buy Ice Cream</button>
    </div>
  )
}

const mapStateToProps = state => {
  return {
    numOfIceCreams: state.numOfIceCreams
  }
}

const mapDispatchToProps = dispatch => {
  return {
    buyIceCream: () => dispatch(buyIceCream())
  }
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(IceCreamContainer)

6. Include IceCreamContainer inside App.js and import it
<Provider store={store}>
    <div className="App">
        <HooksCakeContainer />
        <CakeContainer />
        <IceCreamContainer/>
    </div>
    </Provider>

When we save and look browser,we can see appl is broken because we have split overall global state into state that is individually managed by separate reducers. In rootReducer,we can see cakeReducer is referred as cake and iceCreamReducer is just referred as iceCream, so state object we have defined separately in reducer file also need to access differently 

7. In IceCreamContainer to access numOfIceCreams in mapStateToProps we need to specify as 
    numOfIceCreams: state.iceCream.numOfIceCreams
  Similarly in CakeContainer to access numOfCakes in mapStateToProps we need to specify as 
    numOfCakes: state.cake.numOfCakes
  In HooksCakeContainer also we need to specify
     const numOfCakes = useSelector(state => state.cake.numOfCakes)

When we save and look browser, we can see values show up in browser and actions also should work 

8. Next we apply logger middleware to our react appl, to log all info in console
   - install redux logger
       >npm install redux-logger
   - Import in store.js 
       import logger from 'redux-logger'
   - Now we apply this logger middleware for that we import applyMiddleware 
       import { createStore, applyMiddleware } from 'redux'
   - To createStore function we pass middleware 
       const store = createStore(rootReducer,applyMiddleware(logger))

When we save and look browser, when we click the button u can see all logs in browser console 


Redux Devtool Extension - used for debugging purpose 

1. In google select, add Redux devtool extension to chrome

2. Add redux devtools extension package to our react redux application
   >npm install --save redux-devtools-extension

3. Now we import in store.js 
      import { composeWithDevTools } from 'redux-devtools-extension'

4. We specify composeWithDevTools as second parameter to createStore method 

const store = createStore(
  rootReducer,
  composeWithDevTools(applyMiddleware(logger))
)

When we save and look browser, extension icon is colored, when we click the icon a panel appears with lot of button and texts but if we click outside the panel it closes
   So select Inspect - Redux, u can see the panel

1. When u click on State button, we can see global redux state at any given time
   When u click 'Buy Cake' button, on left side we can see new action is added called 'BUY_CAKE' and state also decrement by 1
2. We have Action button which gives information about the action that was dispatched 
3. In bottom we have dispatcher button, where we can specify an action and dispatch an action without the need of UI element like button
   type: 'BUY_CAKE' and click on dispatch 
4. Play button which gives u an option to travel through all the action and see the state changes which in turn affect UI

How to add payload to action creator?
     Now we have onClick of 'Buy Cake' button we can buy only one cake, to improve that we add an input elt where we specify the number of cakes to buy. If u then click on a button to buy cakes, the numOfCakes will be decremented by appropriate amount 

1. Create NewCakeContainer.js, copy code from CakeContainer and do necessary changes 
   - Change component name to NewCakeContainer 
        In JSX we are displaying number of cakes, after that we create input element to accept the number of cakes that we want to buy
   - import useState from react
       import React, { useState } from 'react'
   - In function body, create new state variable number and setNumber with initialValue as 1 
       const [number, setNumber] = useState(1)
   - Create input element with value as number and on change we call setNumber as event.target.value 
     <input type='text' value={number} onChange={e => setNumber(e.target.value)} />
   - Next we have onClick handler function where we pass in input value as a parameter 
   <button onClick={() => props.buyCake(number)}>Buy X Cakes</button>
   - The method signature we change corresponds to buyCake in mapDispatchToProps, so we need to make change here 
   const mapDispatchToProps = dispatch => {
  return {
    buyCake: number => dispatch(buyCake(number))
  }
}

buyCake(number) corresponds to action creator, so we have to change in cakeActions.js as well. We add that parameter to new property called payload which is equal to number parameter 

export const buyCake = (number = 1) => {
  return {
    type: BUY_CAKE,
    payload: number
  }
}

  - Now we change in cakeRedurer.js, instead of reducing as 1 we reduce as action.payload 

case BUY_CAKE: return {
      ...state,
      numOfCakes: state.numOfCakes - action.payload
    }

    - Include NewCakeContainer in App.js and import it
         <NewCakeContainer />
When we save and look, by default input value is 1 and when we click button the number of cakes decrements 


mapStateToProps function
    - It receives the redux state as parameter which we can then use as props in our component 
    - Second parameter is basically props that have already been passed to components

1. Create ItemContainer.js with rfce create functional component, with this component we want to display either number of cakes or number of icecreams based on prop that is passed from parent container, so it can be reused for both cakes and icecreams.
    In JSX we have h2 tag with item, where we display either number of cakes or icecreams

function ItemContainer() {
    return (
        <div>
            <h2>Item - </h2>
        </div>
    )
}

export default ItemContainer

2. We define mapStateToProps function which takes 2 parameter , first parameter is redux state and second parameter is the props of the component itself which is 'ownProps'
   Now we pass prop called cake from parent container, if that cake prop was passed in we access numOfCakes otherwise numOfIcecreams. Finally we return an object where key is item and value is itemState 

const mapStateToProps = (state, ownProps) => {
  const itemState = ownProps.cake
    ? state.cake.numOfCakes
    : state.iceCream.numOfIceCreams
  return {
    item: itemState
  }
}

   - Now we render props.item which refer to redux state variable for either cake or icecreams 
     <h2>Item - {props.item}</h2>
   - We need to connect store with redux so import connect from redux
         import { connect } from 'react-redux'
   - while exporting call connect
         export default connect(mapStateToProps)(ItemContainer)
   - Include ItemContainer with prop as cake inside App.js and import it
        <ItemContainer cake />
        <ItemContainer />
When we save and look browser, represent cake and icecreams, thiis possible because of cake prop send from parent component 

mapDispatchToProps function
    - We can see second parameter to mapDispatchToProps, now we can conditionally dispatch based on props that is passed from the parent component  

const mapDispatchToProps = (dispatch, ownProps) => {
  const dispatchFunction = ownProps.cake
    ? () => dispatch(buyCake())
    : () => dispatch(buyIceCream())
  return {
    buyItem: dispatchFunction
  }
}
    - While exporting we export second parameter to connect 
export default connect(mapStateToProps,mapDispatchToProps)(ItemContainer)
    - Bind that prop to button click 
   <button onClick={props.buyItem}>Buy Items</button>
When we save and look browser, when we click button cake reduces 

1. To use connect() if you only want to dispatch action but not subscribe to state changes in the store

export default connect(null,mapDispatchToProps)(ItemContainer)   


React Redux Async actions 
Example
   The appl we build is simply fetches a list of users from API endpoint and store in redux store

State:
   For data fetching we go for 3 properties for the state object, first property is loading flag which indicates whether the data is currently being fetched or not, second property is data itself (ie) list of users which is empty array with no user loaded, third property is an error message our api request might fail for some reason in that case we use error property 

Actions
1. FETCH_USERS_REQUEST - Fetch list of users from api endpoint
2. If data is fetched successfully then we use action FETCH_USERS_SUCCESS
3. FETCH_USERS_FAILURE - Error fetching the data 

Reducers
   If action type is FETCH_USERS_REQUEST we basically set loading to true. If action type is FETCH_USERS_SUCCESS then loading is false and data is list of users fetched from API. If action type is FETCH_USERS_FAILURE then loading is false and error to the error returned by API

1. Create UserContainer.js with rfce create functional component, where we render list of users 

function UserContainer() {
    return (
        <div>
            Users
        </div>
    )
}

export default UserContainer

2. Inside redux folder,create new folder called user and create userTypes.js, userActions.js, userReducer.js

userTypes.js

export const FETCH_USERS_REQUEST = 'FETCH_USERS_REQUEST'
export const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS'
export const FETCH_USERS_FAILURE = 'FETCH_USERS_FAILURE'

userActions.js

import {
  FETCH_USERS_REQUEST,
  FETCH_USERS_SUCCESS,
  FETCH_USERS_FAILURE
} from './userTypes'


export const fetchUsersRequest = () => {
  return {
    type: FETCH_USERS_REQUEST
  }
}

export const fetchUsersSuccess = users => {
  return {
    type: FETCH_USERS_SUCCESS,
    payload: users
  }
}

export const fetchUsersFailure = error => {
  return {
    type: FETCH_USERS_FAILURE,
    payload: error
  }
}


userReducer.js
import {
    FETCH_USERS_REQUEST,
    FETCH_USERS_SUCCESS,
    FETCH_USERS_FAILURE
  } from './userTypes'
  
  const initialState = {
    loading: false,
    users: [],
    error: ''
  }
  
  const reducer = (state = initialState, action) => {
    switch (action.type) {
      case FETCH_USERS_REQUEST:
        return {
          ...state,
          loading: true
        }
      case FETCH_USERS_SUCCESS:
        return {
          loading: false,
          users: action.payload,
          error: ''
        }
      case FETCH_USERS_FAILURE:
        return {
          loading: false,
          users: [],
          error: action.payload
        }
      default: return state
    }
  }
  
  export default reducer

3. Export all action creatore in index.js
       export * from './user/userActions'

4. Include UserReducer in combinedReducer() in rootReducer.js
import userReducer from './user/userReducer'

const rootReducer = combineReducers({
  cake: cakeReducer,
  iceCream: iceCreamReducer,
  user: userReducer
})

5. We see how to make GET request to an API endpoint and display fetched data in UI. Axios used to make GET request to API endpoint and redux-thunk will allow us to create async action creators
    >npm install axios redux-thunk

6. Apply redux thunk middleware to redux store, so in store.js
   - Import thunk
       import thunk from 'redux-thunk'
   - Pass to applyMiddleware
       const store = createStore(rootReducer,composeWithDevTools(applyMiddleware(logger,thunk)))

7. In userActions.js we define user action creators, we define function called fetchUsers, using thunk middleware fetchUsers return another function which receives dispatch method as its argument 

export const fetchUsers = () => {
  return (dispatch) => {
    dispatch(fetchUsersRequest())
    axios
      .get('https://jsonplaceholder.typicode.com/users')
      .then(response => {
        // response.data is the users
        const users = response.data
        dispatch(fetchUsersSuccess(users))
      })
      .catch(error => {
        // error.message is the error message
        dispatch(fetchUsersFailure(error.message))
      })
  }
}

8. Now we subscribe userContainer component to the redux store and display the list of users 
   - Import useEffect, connect and fetchUsers action creator 
import React, { useEffect } from 'react'
import { connect } from 'react-redux'
import { fetchUsers } from '../redux'
   - We define mapStateToProps which accept state and access state.user stores in userData and mapDispatchToProps which receive dispatch as parameter and fetchUsers is key which basically dispatches the fetchUsers() action creator
const mapStateToProps = state => {
  return {
    userData: state.user
  }
}

const mapDispatchToProps = dispatch => {
  return {
    fetchUsers: () => dispatch(fetchUsers())
  }
}

   - We need to connect them 
export default connect(mapStateToProps,mapDispatchToProps)(UsersContainer)
   - Now dispatch the action in useEffect
useEffect(() => {
    fetchUsers()
  }, [])
   - Now render the list of users
return userData.loading ? (
    <h2>Loading</h2>
  ) : userData.error ? (
    <h2>{userData.error}</h2>
  ) : (
    <div>
      <h2>Users List</h2>
      <div>
        {userData &&
          userData.users &&
          userData.users.map(user => <p>{user.name}</p>)}
      </div>
    </div>
  )
If userData.loading we render text 'loading', if userData is not loading which means API request is completed we check if there was an error and display error message, if there is no error then we successfull fetch the list of user 

9. Include UserContainer in App.js and import it
      <UserContainer />
When we save and look browser, we can see list of users 


React Router
1. Create react-router-demo project
      >npx create-react-app react-router-demo

2. Remove <header> part from App.js and remove all from App.css
   <div className='App'>
      
   </div>

In App.css, add style
.App {
   display: flex;
   align-items: center;
   flex-direction: column;
}

3. Create components folder inside src, create Header.js with rafce create a component and we use React fragment 

const Header = () => {
    return (
        <><h1>React Router</h1></>
    )
}
export default Header

4. Include Header in App.js and import it
      <Header />
When we save and look browser, we can see text

5. Install react router dom
    >npm install react-router-dom

6. To use react router dom, we need to cover whole react app using <BrowserRouter>

<BrowserRouter>
   <div className="App">
       <Header/>
   </div>
</BrowserRouter>

7. We create different route for different pages  

<BrowserRouter>
      <div className="App">
        <Header />
      </div>
      <Routes>
        <Route path='/' element={} />
        <Route path='/about' element={} />
        <Route path='/profile' element={} />
      </Routes>
</BrowserRouter>

8. Inside src folder, create Pages folder, inside that create 
- Home.js with rafce

const Home = () => {
    return (
        <h1>Home Page</h1>
    )
}
export default Home

- About.js with rafce
const About = () => {
    return (
        <h1>About Page</h1>
    )
}
export default About

- Profile.js with rafce
const Profile = () => {
    return (
        <h1>Profile Page</h1>
    )
}
export default Profile 

- Now configure all components in route
  <Routes>
          <Route path='/' element={<Home />} />
        <Route path='/about' element={<About />} />
        <Route path='/profile' element={<Profile />} />   
        </Routes>  

When we save and look browser, we can see home page. If we give localhost:3000/about we can see  about page  

 - Instead of typing the path each time, we can use HTML <a> tag but it has disadvantage (ie) when we click on <a> tag each time it refresh the page 
   In Header.js we create navigation menu

<>
<h1>React Router</h1>
<ul className='nav'> 
   <li>
     <a href='/'>Home</a>
   </li>
   <li>
     <a href='/about'>About</a>
   </li>
   <li>
     <a href='/profile'>Profile</a>
   </li>
</ul>
</>

In App.css, provide the style
.nav {
   list-style-type: none;
   width: 500px;
   display: flex:
   justify-content: space-evenly;
}

a{
  text-decoration: none;
  color:inherit;
}

When we save and look browser, when we click the <a> tag each time page is refreshed

   - But we dont want to rerender component each time, for that we use <Link> tag of react router dom
<>
<h1>React Router</h1>
<ul className='nav'> 
   <li>
     <Link to='/'>Home</Link>
   </li>
   <li>
     <Link to='/about'>About</Link>
   </li>
   <li>
     <Link to='/profile'>Profile</Link>
   </li>
</ul>
</>

9. If we want to define basename for ur appl

<BrowserRouter basename="/routing">
      <div className="App">
        <Header />
      </div>
      <Routes>
        <Route path='/' element={<Home />} />
        <Route path='/about' element={<About />} />
        <Route path='/profile' element={<Profile />} />
      </Routes>
    </BrowserRouter>

Now we can run "localhost:3000/routing" then it will load home page 

10. Consider ur page is so big that u need to scroll down, so when u change ur route its gonna continue the other page from same position. So whenever u go to different component 

eg: In Home.js we call useEffect and within the body we call window.scroll(0,0), so it will continue the other page from top and not previous position that page was

useEffect(() => {
    window.scroll(0,0)
},[])

11. When u type to someother route that dosent exist, then we want to display some message on page 
   - Inside Pages folder, create NotFound.js with rafce create component

const NotFound = () => {
    return (
        <h1>Requested resource is not found</h1>
    )
}

export default NotFound
  
   - Define Route in App.js
      <Route element={<NotFound/>} />
